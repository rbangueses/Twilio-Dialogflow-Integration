/*
@license
The following license applies to all parts of this software except as
documented below.

    Copyright (c) 2016, Twilio, inc.
    All rights reserved.

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions are
    met:

      1. Redistributions of source code must retain the above copyright
         notice, this list of conditions and the following disclaimer.

      2. Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in
         the documentation and/or other materials provided with the
         distribution.

      3. Neither the name of Twilio nor the names of its contributors may
         be used to endorse or promote products derived from this software
         without specific prior written permission.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

This software includes loglevel under the following license.

    Copyright (c) 2013 Tim Perry

    Permission is hereby granted, free of charge, to any person
    obtaining a copy of this software and associated documentation
    files (the "Software"), to deal in the Software without
    restriction, including without limitation the rights to use,
    copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following
    conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
    OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
    OTHER DEALINGS IN THE SOFTWARE.

This software includes Backoff library under the following license

    Copyright (C) 2012 Mathieu Turcotte

    Permission is hereby granted, free of charge, to any person obtaining a copy of
    this software and associated documentation files (the "Software"), to deal in
    the Software without restriction, including without limitation the rights to
    use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
    of the Software, and to permit persons to whom the Software is furnished to do
    so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.

This software includes Event-to-Promise library under the following license

    Copyright (c) 2014, Julien Fontanet <julien.fontanet@isonoe.net>.

    Permission to use, copy, modify, and/or distribute this software for any purpose
    with or without fee is hereby granted, provided that the above copyright notice
    and this permission notice appear in all copies.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
    FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
    OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
    TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
    THIS SOFTWARE.

*/
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib_es6 = require('./node_modules/tslib/tslib.es6.js');
var _polyfillNode_events = require('./_virtual/_polyfill-node_events.js');
var declarativeTypeValidator = require('@twilio/declarative-type-validator');
var twilsock = require('twilsock');
var uri = require('./utils/uri.js');
var syncerror = require('./utils/syncerror.js');
var sanitize = require('./utils/sanitize.js');
var logger = require('./utils/logger.js');
var configuration = require('./configuration.js');
var subscriptions = require('./subscriptions.js');
var network = require('./services/network.js');
var storage = require('./services/storage.js');
var syncdocument = require('./syncdocument.js');
var synclist = require('./synclist.js');
var syncmap = require('./syncmap.js');
var syncstream = require('./streams/syncstream.js');
var clientInfo = require('./clientInfo.js');
var entitiesCache = require('./entitiesCache.js');
var livequery = require('./livequery.js');
var _package = require('./packages/sync/package.json.js');

const SYNC_PRODUCT_ID = 'data_sync';
const SDK_VERSION = _package.version;
function decompose(arg) {
    if (!arg) {
        return { mode: 'create_new' };
    }
    else if (typeof arg === 'string') {
        return { id: arg, mode: 'open_or_create' };
    }
    else {
        let mode = arg.mode || (arg.id ? 'open_or_create' : 'create_new');
        return Object.assign(Object.assign({}, arg), { mode: mode });
    }
}
const SYNC_DOCUMENT_NOTIFICATION_TYPE = 'com.twilio.rtd.cds.document';
const SYNC_LIST_NOTIFICATION_TYPE = 'com.twilio.rtd.cds.list';
const SYNC_MAP_NOTIFICATION_TYPE = 'com.twilio.rtd.cds.map';
const SYNC_NOTIFICATION_TYPE = 'twilio.sync.event';
/**
 * Client for the Twilio Sync service.
 *
 * @example
 * ```typescript
 * // Using NPM resolution
 * const SyncClient = require('twilio-sync');
 * const syncClient = new SyncClient(token, { loglevel: 'debug' });
 *
 * // Using CDN
 * const syncClient = new Twilio.Sync.Client(token, { logLevel: 'debug' });
 * ```
 */
class Client extends _polyfillNode_events['default'] {
    /**
     * @param fpaToken Twilio access token.
     * @param options Options to customize the client.
     */
    constructor(fpaToken, options = {}) {
        super();
        if (!fpaToken) {
            throw new Error('Sync library needs a valid Twilio token to be passed');
        }
        if (options.hasOwnProperty('logLevel')) {
            logger['default'].setLevel(options.logLevel);
        }
        else {
            logger['default'].setLevel('silent');
        }
        const productId = options.productId = options.productId || SYNC_PRODUCT_ID;
        // Fill ClientMetadata
        options.clientMetadata = options.clientMetadata || {};
        if (!options.clientMetadata.hasOwnProperty('type')) {
            options.clientMetadata.type = 'sync';
        }
        if (!options.clientMetadata.hasOwnProperty('sdk')) {
            options.clientMetadata.sdk = 'JS';
            options.clientMetadata.sdkv = SDK_VERSION;
        }
        const startTwilsock = !options.twilsockClient;
        // Create default init registrations if none were provided.
        // Otherwise, the outside party have to list all the init registrations they need, including Sync ones.
        if (!options.initRegistrations) {
            let initRegistration = new twilsock.InitRegistration(productId);
            Client.populateInitRegistrations(initRegistration);
            options.initRegistrations = [initRegistration];
        }
        let twilsock$1 = options.twilsockClient = options.twilsockClient || new twilsock.Twilsock(fpaToken, productId, options);
        twilsock$1.on('tokenAboutToExpire', ttl => this.emit('tokenAboutToExpire', ttl));
        twilsock$1.on('tokenExpired', () => this.emit('tokenExpired'));
        twilsock$1.on('connectionError', err => this.emit('connectionError', err));
        twilsock$1.on('stateChanged', (state) => {
            this.emit('connectionStateChanged', state);
            /**
             * Handle transport establishing event
             * If we have any subscriptions - we should check object for modifications
             */
            this.services.subscriptions.onConnectionStateChanged(state === 'connected');
        });
        twilsock$1.on('message', (messageType, payload) => this._routeMessage(messageType, payload));
        let config = new configuration.Configuration(options);
        let network$1 = new network.NetworkService(new clientInfo['default'](SDK_VERSION), config, twilsock$1);
        let storage$1 = new storage.SessionStorage(config);
        this.services = {
            config,
            twilsock: twilsock$1,
            network: network$1,
            storage: storage$1,
            router: this,
            subscriptions: null
        };
        this.services.subscriptions = new subscriptions.Subscriptions(this.services);
        this.entities = new entitiesCache.EntitiesCache();
        // Start only if we created twilsock locally,
        // otherwise it's the responsibility of whoever created the Twilsock client.
        if (startTwilsock) {
            twilsock$1.connect();
        }
    }
    static populateInitRegistrations(reg) {
        reg.populateInitRegistrations([SYNC_NOTIFICATION_TYPE, SYNC_DOCUMENT_NOTIFICATION_TYPE,
            SYNC_LIST_NOTIFICATION_TYPE, SYNC_MAP_NOTIFICATION_TYPE]);
    }
    /**
     * Entry point for all the incoming messages (Router).
     *
     * @param type Type of the incoming message
     * @param message Message to route
     * @internal
     */
    _routeMessage(type, message) {
        logger['default'].trace('Notification type:', type, 'content:', message);
        switch (type) {
            case SYNC_DOCUMENT_NOTIFICATION_TYPE:
            case SYNC_LIST_NOTIFICATION_TYPE:
            case SYNC_MAP_NOTIFICATION_TYPE:
                this.services.subscriptions.acceptMessage(message, false);
                break;
            case SYNC_NOTIFICATION_TYPE:
                this.services.subscriptions.acceptMessage(message, true);
                break;
        }
    }
    /**
     * Subscribe for events (Router)
     *
     * @internal
     */
    _subscribe(sid, entity) {
        this.services.subscriptions.add(sid, entity);
    }
    /**
     * Unsubscribe from events (Router)
     *
     * @internal
     */
    _unsubscribe(sid) {
        this.services.subscriptions.remove(sid);
    }
    /**
     * Current version of the Sync client.
     */
    static get version() {
        return SDK_VERSION;
    }
    /**
     * Current service connection state.
     */
    get connectionState() {
        return this.services.twilsock.state;
    }
    /**
     * Returns a promise which resolves when library is correctly initialized
     * Or throws if initialization is impossible
     *
     * @internal
     */
    async ensureReady() {
        if (!this.services.config.sessionStorageEnabled) {
            return;
        }
        try {
            let storageSettings = await this.services.twilsock.storageId();
            this.services.storage.updateStorageId(storageSettings.id);
        }
        catch (e) {
            logger['default'].warn('Failed to initialize storage', e);
        }
    }
    storeRootInSessionCache(type, id, value) {
        // can't store without id
        if (!this.services.config.sessionStorageEnabled || !id) {
            return;
        }
        let valueToStore = sanitize.deepClone(value);
        if (type === synclist.SyncList.type || type === syncmap.SyncMap.type) {
            valueToStore['last_event_id'] = null;
            delete valueToStore['items'];
        }
        this.services.storage.store(type, id, valueToStore);
    }
    readRootFromSessionCache(type, id) {
        if (!this.services.config.sessionStorageEnabled || !id) {
            return null;
        }
        return this.services.storage.read(type, id);
    }
    async _get(baseUri, id, optimistic = false) {
        if (!id) {
            throw new syncerror.SyncError(`Cannot get entity without id`, 404);
        }
        const uri$1 = new uri.UriBuilder(baseUri).pathSegment(id)
            .queryParam('Include', optimistic ? 'items' : undefined).build();
        let response = await this.services.network.get(uri$1);
        return response.body;
    }
    _createDocument(id, data, ttl) {
        const requestBody = {
            unique_name: id,
            data: data || {}
        };
        if (ttl !== undefined) {
            requestBody.ttl = ttl;
        }
        return this.services.network.post(this.services.config.documentsUri, requestBody)
            .then(response => {
            response.body.data = requestBody.data;
            return response.body;
        });
    }
    async _getDocument(id) {
        return (this.readRootFromSessionCache(syncdocument.SyncDocument.type, id) || this._get(this.services.config.documentsUri, id));
    }
    _createList(id, purpose, context, ttl) {
        const requestBody = {
            unique_name: id,
            purpose: purpose,
            context: context
        };
        if (ttl !== undefined) {
            requestBody.ttl = ttl;
        }
        return this.services.network.post(this.services.config.listsUri, requestBody).then(response => response.body);
    }
    async _getList(id) {
        return (this.readRootFromSessionCache(synclist.SyncList.type, id) || this._get(this.services.config.listsUri, id));
    }
    _createMap(id, ttl) {
        const requestBody = {
            unique_name: id
        };
        if (ttl !== undefined) {
            requestBody.ttl = ttl;
        }
        return this.services.network.post(this.services.config.mapsUri, requestBody).then(response => response.body);
    }
    async _getMap(id, optimistic = false) {
        return (this.readRootFromSessionCache(syncmap.SyncMap.type, id) || this._get(this.services.config.mapsUri, id, optimistic));
    }
    async _getStream(id) {
        return (this.readRootFromSessionCache(syncstream.SyncStream.type, id) || this._get(this.services.config.streamsUri, id, false));
    }
    async _createStream(id, ttl) {
        const requestBody = {
            unique_name: id
        };
        if (ttl !== undefined) {
            requestBody.ttl = ttl;
        }
        const response = await this.services.network.post(this.services.config.streamsUri, requestBody);
        return response.body;
    }
    _getLiveQuery(sid) {
        return this.readRootFromSessionCache(livequery.LiveQuery.type, sid);
    }
    getCached(id, type) {
        if (id) {
            return this.entities.get(id, type) || null;
        }
        return null;
    }
    removeFromCacheAndSession(type, sid, uniqueName) {
        this.entities.remove(sid);
        if (this.services.config.sessionStorageEnabled) {
            this.services.storage.remove(type, sid, uniqueName);
        }
    }
    /**
     * Read or create a Sync document.
     * @param arg Could be any of the following:
     * * Unique name or SID identifying the Sync document - opens the document with the given identifier or creates one if it does not exist.
     * * none - creates a new document with a randomly assigned SID and no unique name.
     * * {@link OpenDocumentOptions} object for more granular control.
     * @return A promise which resolves after the document is successfully read (or created).
     * This promise may reject if the document could not be created or if this endpoint lacks the necessary permissions to access it.
     * @example
     * ```typescript
     * syncClient.document('MyDocument')
     *   .then((document) => {
     *     console.log('Successfully opened a document. SID:', document.sid);
     *     document.on('updated', (event) => {
     *       console.log('Received an "updated" event: ', event);
     *     });
     *   })
     *   .catch((error) => {
     *     console.error('Unexpected error', error);
     *   });
     * ```
     */
    async document(arg) {
        await this.ensureReady();
        let opts = decompose(arg);
        let docDescriptor;
        if (opts.mode === 'create_new') {
            docDescriptor = await this._createDocument(opts.id, opts.data, opts.ttl);
        }
        else {
            let docFromInMemoryCache = this.getCached(opts.id, syncdocument.SyncDocument.type);
            if (docFromInMemoryCache) {
                return new syncdocument.SyncDocument(docFromInMemoryCache);
            }
            else {
                try {
                    docDescriptor = await this._getDocument(opts.id);
                }
                catch (err) {
                    if (err.status !== 404 || opts.mode === 'open_existing') {
                        throw err;
                    }
                    else {
                        try {
                            docDescriptor = await this._createDocument(opts.id, opts.data, opts.ttl);
                        }
                        catch (err) {
                            if (err.status === 409) {
                                return this.document(arg);
                            }
                            else {
                                throw err;
                            }
                        }
                    }
                }
            }
        }
        this.storeRootInSessionCache(syncdocument.SyncDocument.type, opts.id, docDescriptor);
        let syncDocumentImpl = new syncdocument.SyncDocumentImpl(this.services, docDescriptor, (type, sid, uniqueName) => this.removeFromCacheAndSession(type, sid, uniqueName));
        syncDocumentImpl = this.entities.store(syncDocumentImpl);
        return new syncdocument.SyncDocument(syncDocumentImpl);
    }
    /**
     * Read or create a Sync map.
     * @param arg Could be any of the following:
     * * Unique name or SID identifying the Sync map - opens the map with the given identifier or creates one if it does not exist.
     * * none - creates a new map with a randomly assigned SID and no unique name.
     * * {@link OpenMapOptions} object for more granular control.
     * @return A promise which resolves after the map is successfully read (or created).
     * This promise may reject if the map could not be created or if this endpoint lacks the necessary permissions to access it.
     * @example
     * ```typescript
     * syncClient.map('MyMap')
     *   .then((map) => {
     *     console.log('Successfully opened a map. SID:', map.sid);
     *     map.on('itemUpdated', (event) => {
     *       console.log('Received an "itemUpdated" event:', event);
     *     });
     *   })
     *   .catch((error) => {
     *     console.error('Unexpected error', error);
     *   });
     * ```
     */
    async map(arg) {
        await this.ensureReady();
        let opts = decompose(arg);
        let mapDescriptor;
        if (opts.mode === 'create_new') {
            mapDescriptor = await this._createMap(opts.id, opts.ttl);
        }
        else {
            let mapFromInMemoryCache = this.getCached(opts.id, syncmap.SyncMap.type);
            if (mapFromInMemoryCache) {
                return new syncmap.SyncMap(mapFromInMemoryCache);
            }
            else {
                try {
                    mapDescriptor = await this._getMap(opts.id, opts.includeItems);
                }
                catch (err) {
                    if (err.status !== 404 || opts.mode === 'open_existing') {
                        throw err;
                    }
                    else {
                        try {
                            mapDescriptor = await this._createMap(opts.id, opts.ttl);
                        }
                        catch (err) {
                            if (err.status === 409) {
                                return this.map(arg);
                            }
                            else {
                                throw err;
                            }
                        }
                    }
                }
            }
        }
        this.storeRootInSessionCache(syncmap.SyncMap.type, opts.id, mapDescriptor);
        let syncMapImpl = new syncmap.SyncMapImpl(this.services, mapDescriptor, (type, sid, uniqueName) => this.removeFromCacheAndSession(type, sid, uniqueName));
        syncMapImpl = this.entities.store(syncMapImpl);
        return new syncmap.SyncMap(syncMapImpl);
    }
    /**
     * Read or create a Sync list.
     * @param arg Could be any of the following:
     * * Unique name or SID identifying a Sync list - opens the list with the given identifier or creates one if it does not exist.
     * * none - creates a new list with a randomly assigned SID and no unique name.
     * * {@link OpenListOptions} object for more granular control.
     * @return A promise which resolves after the list is successfully read (or created).
     * This promise may reject if the list could not be created or if this endpoint lacks the necessary permissions to access it.
     * @example
     * ```typescript
     * syncClient.list('MyList')
     *   .then((list) => {
     *     console.log('Successfully opened a List. SID:', list.sid);
     *     list.on('itemAdded', (event) => {
     *       console.log('Received an "itemAdded" event:', event);
     *     });
     *   })
     *   .catch((error) => {
     *     console.error('Unexpected error', error);
     *   });
     * ```
     */
    async list(arg) {
        await this.ensureReady();
        let opts = decompose(arg);
        let listDescriptor;
        if (opts.mode === 'create_new') {
            listDescriptor = await this._createList(opts.id, opts.purpose, opts.context, opts.ttl);
        }
        else {
            let listFromInMemoryCache = this.getCached(opts.id, synclist.SyncList.type);
            if (listFromInMemoryCache) {
                return new synclist.SyncList(listFromInMemoryCache);
            }
            else {
                try {
                    listDescriptor = await this._getList(opts.id);
                }
                catch (err) {
                    if (err.status !== 404 || opts.mode === 'open_existing') {
                        throw err;
                    }
                    else {
                        try {
                            listDescriptor = await this._createList(opts.id, opts.purpose, opts.context, opts.ttl);
                        }
                        catch (err) {
                            if (err.status === 409) {
                                return this.list(arg);
                            }
                            else {
                                throw err;
                            }
                        }
                    }
                }
            }
        }
        this.storeRootInSessionCache(synclist.SyncList.type, opts.id, listDescriptor);
        let syncListImpl = new synclist.SyncListImpl(this.services, listDescriptor, (type, sid, uniqueName) => this.removeFromCacheAndSession(type, sid, uniqueName));
        syncListImpl = this.entities.store(syncListImpl);
        return new synclist.SyncList(syncListImpl);
    }
    /**
     * Read or create a Sync message stream.
     * @param arg Could be any of the following:
     * * Unique name or SID identifying a stream - opens the stream with the given identifier or creates one if it does not exist.
     * * none - creates a new stream with a randomly assigned SID and no unique name.
     * * {@link OpenStreamOptions} object for more granular control.
     * @return A promise which resolves after the stream is successfully read (or created).
     * The flow of messages will begin imminently (but not necessarily immediately) upon resolution.
     * This promise may reject if the stream could not be created or if this endpoint lacks the necessary permissions to access it.
     * @example
     * ```typescript
     * syncClient.stream('MyStream')
     *   .then((stream) => {
     *     console.log('Successfully opened a message stream. SID:', stream.sid);
     *     stream.on('messagePublished', (event) => {
     *       console.log('Received a "messagePublished" event:', event);
     *     });
     *   })
     *   .catch((error) => {
     *     console.error('Unexpected error', error);
     *   });
     * ```
     */
    async stream(arg) {
        await this.ensureReady();
        let opts = decompose(arg);
        let streamDescriptor;
        if (opts.mode === 'create_new') {
            streamDescriptor = await this._createStream(opts.id, opts.ttl);
        }
        else {
            let streamFromInMemoryCache = this.getCached(opts.id, syncstream.SyncStream.type);
            if (streamFromInMemoryCache) {
                return new syncstream.SyncStream(streamFromInMemoryCache);
            }
            else {
                try {
                    streamDescriptor = await this._getStream(opts.id);
                }
                catch (err) {
                    if (err.status !== 404 || opts.mode === 'open_existing') {
                        throw err;
                    }
                    else {
                        try {
                            streamDescriptor = await this._createStream(opts.id, opts.ttl);
                        }
                        catch (err) {
                            if (err.status === 409) {
                                return this.stream(arg);
                            }
                            else {
                                throw err;
                            }
                        }
                    }
                }
            }
        }
        this.storeRootInSessionCache(syncstream.SyncStream.type, opts.id, streamDescriptor);
        const streamRemovalHandler = (type, sid, uniqueName) => this.removeFromCacheAndSession(type, sid, uniqueName);
        let syncStreamImpl = new syncstream.SyncStreamImpl(this.services, streamDescriptor, streamRemovalHandler);
        syncStreamImpl = this.entities.store(syncStreamImpl);
        return new syncstream.SyncStream(syncStreamImpl);
    }
    /**
     * Gracefully shuts the Sync client down.
     */
    async shutdown() {
        await this.services.subscriptions.shutdown();
        await this.services.twilsock.disconnect();
    }
    /**
     * Set the authentication token.
     * @param token New token to set.
     */
    async updateToken(token) {
        return this.services.twilsock.updateToken(token)
            .catch((error) => {
            var _a;
            const status = (_a = error === null || error === void 0 ? void 0 : error.reply) === null || _a === void 0 ? void 0 : _a.status;
            if ((status === null || status === void 0 ? void 0 : status.code) === 401 && (status === null || status === void 0 ? void 0 : status.status) === 'UNAUTHORIZED') {
                throw new syncerror.SyncError('Updated token was rejected by server', 400, 51130);
            }
            throw error;
        });
    }
    /**
     * For Flex customers only. Establishes a long-running query against Flex data wherein the returned
     * result set is updated whenever new (or updated) records match the given expression. Updated results
     * are presented row-by-row according to the lifetime of the returned LiveQuery object.
     *
     * @param indexName Must specify one of the Flex data classes for which Live Queries are available.
     * @param queryExpression A query expression to be executed against the given data index.
     * Please review the [Live Query Language](https://www.twilio.com/docs/sync/live-query)
     * page for Sync client limits and a full list of operators currently supported in query expressions.
     *
     * @return A promise that resolves when the query has been successfully executed.
     * @example
     * ```typescript
     * syncClient.liveQuery('tr-worker', 'data.attributes.worker_name == "Bob"')
     *   .then((args) => {
     *      console.log('Subscribed to live data updates for worker Bob');
     *      const items = args.getItems();
     *      Object.entries(items).forEach(([key, value]) => {
     *        console.log('Search result item key:', key);
     *        console.log('Search result item value:', value);
     *      });
     *   })
     *   .catch((err) => {
     *      console.error('Error when subscribing to live updates for worker Bob', err);
     *   });
     * ```
     */
    async liveQuery(indexName, queryExpression) {
        await this.ensureReady();
        const queryUri = new uri.UriBuilder(this.services.config.insightsUri)
            .pathSegment(indexName)
            .pathSegment('Items')
            .build();
        // send query to CDS to get server-generated sid and item list
        const response = await livequery.queryItems({
            network: this.services.network,
            uri: queryUri,
            queryString: queryExpression,
            type: livequery.LiveQuery.type
        });
        let liveQueryImpl = this.getCached(response.query_id, livequery.LiveQuery.type);
        if (!liveQueryImpl) {
            let descriptor = this._getLiveQuery(response.query_id);
            if (!descriptor) {
                descriptor = {
                    indexName,
                    queryExpression,
                    sid: response.query_id,
                    queryUri,
                    last_event_id: response.last_event_id
                };
            }
            const liveQueryRemovalHandler = (type, sid, uniqueName) => this.removeFromCacheAndSession(type, sid, uniqueName);
            liveQueryImpl = new livequery.LiveQueryImpl(descriptor, this.services, liveQueryRemovalHandler, response.items);
        }
        this.storeRootInSessionCache(livequery.LiveQuery.type, response.query_id, liveQueryImpl.liveQueryDescriptor);
        liveQueryImpl = this.entities.store(liveQueryImpl);
        return new livequery.LiveQuery(liveQueryImpl);
    }
    /**
     * For Flex customers only. Creates a query object that can be used to issue one-time queries repeatedly
     * against the target index.
     *
     * @param indexName Must specify one of the Flex data classes for which live queries are available.
     * @return A promise which resolves after the instance of InstantQuery is successfully created.
     * @example
     * ```typescript
     * syncClient.instantQuery('tr-worker')
     *   .then((q) => {
     *     q.on('searchResult', (items) => {
     *       Object.entries(items).forEach(([key, value]) => {
     *         console.log('Search result item key:', key);
     *         console.log('Search result item value:', value);
     *       });
     *     });
     *   });
     * ```
     */
    async instantQuery(indexName) {
        await this.ensureReady();
        const liveQueryCreator = (indexName, queryExpression) => {
            return this.liveQuery(indexName, queryExpression);
        };
        return new livequery.InstantQuery({
            indexName,
            network: this.services.network,
            insightsUri: this.services.config.insightsUri,
            liveQueryCreator
        });
    }
}
/**
 * Fired when connection state has been changed.
 *
 * Parameters:
 * 1. {@link ConnectionState} `connectionState` - contains current service connection state.
 * @example
 * ```typescript
 * syncClient.on('connectionStateChanged', (newState) => {
 *   console.log('Received a new connection state:', newState);
 * });
 * ```
 * @event
 */
Client.connectionStateChanged = 'connectionStateChanged';
/**
 * Fired when connection is interrupted by unexpected reason.
 *
 * Parameters:
 * 1. object `connectionError` - connection error details. It has following properties:
 *     * boolean `terminal` - twilsock will stop connection attempts
 *     * string `message` - root cause
 *     * number? `httpStatusCode` - HTTP status code if available
 *     * number? `errorCode` - Twilio public error code if available
 * @example
 * ```typescript
 * syncClient.on('connectionError', (connectionError) => {
 *   console.error('Connection was interrupted:', connectionError.message);
 *   console.error('Is terminal:', connectionError.terminal);
 * });
 * ```
 * @event
 */
Client.connectionError = 'connectionError';
/**
 * Fired when the access token is about to expire and needs to be updated.
 * The trigger takes place three minutes before the JWT access token expiry.
 * For long living applications, you should refresh the token when either
 * {@link SyncClient.tokenAboutToExpire | tokenAboutToExpire} or
 * {@link SyncClient.tokenExpired | tokenExpire} events occur; handling just
 * one of them is sufficient.
 * @example
 * The following example illustrates access token refresh.
 * ```typescript
 * syncClient.on('tokenAboutToExpire', () => {
 *   // Obtain a JWT access token: https://www.twilio.com/docs/sync/identity-and-access-tokens
 *   const token = '<your-access-token-here>';
 *   syncClient.updateToken(token);
 * });
 * ```
 * @event
 */
Client.tokenAboutToExpire = 'tokenAboutToExpire';
/**
 * Fired when the access token is expired.
 * In case the token is not refreshed, all subsequent Sync operations will fail and the client will disconnect.
 * For long living applications, you should refresh the token when either
 * {@link SyncClient.tokenAboutToExpire | tokenAboutToExpire} or
 * {@link SyncClient.tokenExpired | tokenExpire} events occur; handling just
 * one of them is sufficient.
 * @event
 */
Client.tokenExpired = 'tokenExpired';
tslib_es6.__decorate([
    declarativeTypeValidator.validateTypesAsync([
        'undefined',
        'string',
        declarativeTypeValidator.objectSchema('open document options', {
            id: ['string', 'undefined'],
            mode: [declarativeTypeValidator.literal('open_or_create', 'open_existing', 'create_new'), 'undefined'],
            ttl: [declarativeTypeValidator.nonNegativeInteger, 'undefined'],
            data: [declarativeTypeValidator.pureObject, 'undefined', declarativeTypeValidator.literal(null)]
        })
    ]),
    tslib_es6.__metadata("design:type", Function),
    tslib_es6.__metadata("design:paramtypes", [Object]),
    tslib_es6.__metadata("design:returntype", Promise)
], Client.prototype, "document", null);
tslib_es6.__decorate([
    declarativeTypeValidator.validateTypesAsync([
        'undefined',
        'string',
        declarativeTypeValidator.objectSchema('open map options', {
            id: ['string', 'undefined'],
            mode: [declarativeTypeValidator.literal('open_or_create', 'open_existing', 'create_new'), 'undefined'],
            ttl: [declarativeTypeValidator.nonNegativeInteger, 'undefined'],
            data: [declarativeTypeValidator.pureObject, 'undefined', declarativeTypeValidator.literal(null)],
            includeItems: ['boolean', 'undefined']
        })
    ]),
    tslib_es6.__metadata("design:type", Function),
    tslib_es6.__metadata("design:paramtypes", [Object]),
    tslib_es6.__metadata("design:returntype", Promise)
], Client.prototype, "map", null);
tslib_es6.__decorate([
    declarativeTypeValidator.validateTypesAsync([
        'undefined',
        'string',
        declarativeTypeValidator.objectSchema('open list options', {
            id: ['string', 'undefined'],
            mode: [declarativeTypeValidator.literal('open_or_create', 'open_existing', 'create_new'), 'undefined'],
            ttl: [declarativeTypeValidator.nonNegativeInteger, 'undefined'],
            data: [declarativeTypeValidator.pureObject, 'undefined', declarativeTypeValidator.literal(null)],
            purpose: ['string', 'undefined'],
            context: [declarativeTypeValidator.pureObject, 'undefined'],
            includeItems: ['boolean', 'undefined']
        })
    ]),
    tslib_es6.__metadata("design:type", Function),
    tslib_es6.__metadata("design:paramtypes", [Object]),
    tslib_es6.__metadata("design:returntype", Promise)
], Client.prototype, "list", null);
tslib_es6.__decorate([
    declarativeTypeValidator.validateTypesAsync([
        'undefined',
        'string',
        declarativeTypeValidator.objectSchema('open stream options', {
            id: ['string', 'undefined'],
            mode: [declarativeTypeValidator.literal('open_or_create', 'open_existing', 'create_new'), 'undefined'],
            ttl: [declarativeTypeValidator.nonNegativeInteger, 'undefined'],
            data: [declarativeTypeValidator.pureObject, 'undefined', declarativeTypeValidator.literal(null)]
        })
    ]),
    tslib_es6.__metadata("design:type", Function),
    tslib_es6.__metadata("design:paramtypes", [Object]),
    tslib_es6.__metadata("design:returntype", Promise)
], Client.prototype, "stream", null);
tslib_es6.__decorate([
    declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonEmptyString),
    tslib_es6.__metadata("design:type", Function),
    tslib_es6.__metadata("design:paramtypes", [String]),
    tslib_es6.__metadata("design:returntype", Promise)
], Client.prototype, "updateToken", null);
tslib_es6.__decorate([
    declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonEmptyString, 'string'),
    tslib_es6.__metadata("design:type", Function),
    tslib_es6.__metadata("design:paramtypes", [String, String]),
    tslib_es6.__metadata("design:returntype", Promise)
], Client.prototype, "liveQuery", null);
tslib_es6.__decorate([
    declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonEmptyString),
    tslib_es6.__metadata("design:type", Function),
    tslib_es6.__metadata("design:paramtypes", [String]),
    tslib_es6.__metadata("design:returntype", Promise)
], Client.prototype, "instantQuery", null);

exports.Client = Client;
//# sourceMappingURL=client.js.map
