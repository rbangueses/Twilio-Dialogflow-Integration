/*
@license
The following license applies to all parts of this software except as
documented below.

    Copyright (c) 2016, Twilio, inc.
    All rights reserved.

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions are
    met:

      1. Redistributions of source code must retain the above copyright
         notice, this list of conditions and the following disclaimer.

      2. Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in
         the documentation and/or other materials provided with the
         distribution.

      3. Neither the name of Twilio nor the names of its contributors may
         be used to endorse or promote products derived from this software
         without specific prior written permission.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

This software includes loglevel under the following license.

    Copyright (c) 2013 Tim Perry

    Permission is hereby granted, free of charge, to any person
    obtaining a copy of this software and associated documentation
    files (the "Software"), to deal in the Software without
    restriction, including without limitation the rights to use,
    copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following
    conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
    OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
    OTHER DEALINGS IN THE SOFTWARE.

This software includes Backoff library under the following license

    Copyright (C) 2012 Mathieu Turcotte

    Permission is hereby granted, free of charge, to any person obtaining a copy of
    this software and associated documentation files (the "Software"), to deal in
    the Software without restriction, including without limitation the rights to
    use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
    of the Software, and to permit persons to whom the Software is furnished to do
    so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.

This software includes Event-to-Promise library under the following license

    Copyright (c) 2014, Julien Fontanet <julien.fontanet@isonoe.net>.

    Permission to use, copy, modify, and/or distribute this software for any purpose
    with or without fee is hereby granted, provided that the above copyright notice
    and this permission notice appear in all copies.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
    FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
    OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
    TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
    THIS SOFTWARE.

*/
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

require('core-js/modules/es.object.keys.js');
require('core-js/modules/es.symbol.js');
require('core-js/modules/es.array.filter.js');
require('core-js/modules/es.object.get-own-property-descriptor.js');
require('core-js/modules/web.dom-collections.for-each.js');
require('core-js/modules/es.object.get-own-property-descriptors.js');
require('core-js/modules/es.reflect.construct.js');
var _asyncToGenerator = require('@babel/runtime/helpers/asyncToGenerator');
var _classCallCheck = require('@babel/runtime/helpers/classCallCheck');
var _createClass = require('@babel/runtime/helpers/createClass');
var _assertThisInitialized = require('@babel/runtime/helpers/assertThisInitialized');
var _inherits = require('@babel/runtime/helpers/inherits');
var _possibleConstructorReturn = require('@babel/runtime/helpers/possibleConstructorReturn');
var _getPrototypeOf = require('@babel/runtime/helpers/getPrototypeOf');
var _defineProperty = require('@babel/runtime/helpers/defineProperty');
require('core-js/modules/es.array.map.js');
require('core-js/modules/es.object.to-string.js');
require('core-js/modules/es.promise.js');
var _regeneratorRuntime = require('@babel/runtime/regenerator');
var _typeof = require('@babel/runtime/helpers/typeof');
var declarativeTypeValidator = require('@twilio/declarative-type-validator');
var twilsock = require('twilsock');
require('core-js/modules/es.array.join.js');
var _wrapNativeSuper = require('@babel/runtime/helpers/wrapNativeSuper');
require('core-js/modules/es.function.name.js');
require('core-js/modules/es.array.concat.js');
require('core-js/modules/es.array.includes.js');
require('core-js/modules/es.array.from.js');
require('core-js/modules/es.string.iterator.js');
var loglevelLog = require('loglevel');
require('core-js/modules/es.array.slice.js');
require('core-js/modules/es.symbol.description.js');
require('core-js/modules/es.symbol.iterator.js');
var _slicedToArray = require('@babel/runtime/helpers/slicedToArray');
require('core-js/modules/es.array.iterator.js');
require('core-js/modules/es.map.js');
require('core-js/modules/web.dom-collections.iterator.js');
require('core-js/modules/es.object.assign.js');
require('core-js/modules/es.regexp.exec.js');
require('core-js/modules/es.string.match.js');
var operationRetrier = require('@twilio/operation-retrier');
require('core-js/modules/es.string.replace.js');
var uuid = require('uuid');
var _get = require('@babel/runtime/helpers/get');
require('core-js/modules/es.number.constructor.js');
var platform = require('platform');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () {
                        return e[k];
                    }
                });
            }
        });
    }
    n['default'] = e;
    return Object.freeze(n);
}

var _asyncToGenerator__default = /*#__PURE__*/_interopDefaultLegacy(_asyncToGenerator);
var _classCallCheck__default = /*#__PURE__*/_interopDefaultLegacy(_classCallCheck);
var _createClass__default = /*#__PURE__*/_interopDefaultLegacy(_createClass);
var _assertThisInitialized__default = /*#__PURE__*/_interopDefaultLegacy(_assertThisInitialized);
var _inherits__default = /*#__PURE__*/_interopDefaultLegacy(_inherits);
var _possibleConstructorReturn__default = /*#__PURE__*/_interopDefaultLegacy(_possibleConstructorReturn);
var _getPrototypeOf__default = /*#__PURE__*/_interopDefaultLegacy(_getPrototypeOf);
var _defineProperty__default = /*#__PURE__*/_interopDefaultLegacy(_defineProperty);
var _regeneratorRuntime__default = /*#__PURE__*/_interopDefaultLegacy(_regeneratorRuntime);
var _typeof__default = /*#__PURE__*/_interopDefaultLegacy(_typeof);
var _wrapNativeSuper__default = /*#__PURE__*/_interopDefaultLegacy(_wrapNativeSuper);
var loglevelLog__namespace = /*#__PURE__*/_interopNamespace(loglevelLog);
var _slicedToArray__default = /*#__PURE__*/_interopDefaultLegacy(_slicedToArray);
var uuid__namespace = /*#__PURE__*/_interopNamespace(uuid);
var _get__default = /*#__PURE__*/_interopDefaultLegacy(_get);
var platform__namespace = /*#__PURE__*/_interopNamespace(platform);

function __decorate(decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if ((typeof Reflect === "undefined" ? "undefined" : _typeof__default['default'](Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  }
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __metadata(metadataKey, metadataValue) {
  if ((typeof Reflect === "undefined" ? "undefined" : _typeof__default['default'](Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

var domain;

// This constructor is used to store event handlers. Instantiating this is
// faster than explicitly calling `Object.create(null)` to get a "clean" empty
// object (tested with v8 v4.9).
function EventHandlers() {}
EventHandlers.prototype = Object.create(null);

function EventEmitter() {
  EventEmitter.init.call(this);
}

// nodejs oddity
// require('events') === require('events').EventEmitter
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.usingDomains = false;

EventEmitter.prototype.domain = undefined;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

EventEmitter.init = function() {
  this.domain = null;
  if (EventEmitter.usingDomains) {
    // if there is an active domain, then attach to it.
    if (domain.active ) ;
  }

  if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
    this._events = new EventHandlers();
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || isNaN(n))
    throw new TypeError('"n" argument must be a positive number');
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

// These standalone emit* functions are used to optimize calling of event
// handlers for fast cases because emit() itself often has a variable number of
// arguments and can be deoptimized because of that. These functions always have
// the same number of arguments and thus do not get deoptimized, so the code
// inside them can execute faster.
function emitNone(handler, isFn, self) {
  if (isFn)
    handler.call(self);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self);
  }
}
function emitOne(handler, isFn, self, arg1) {
  if (isFn)
    handler.call(self, arg1);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1);
  }
}
function emitTwo(handler, isFn, self, arg1, arg2) {
  if (isFn)
    handler.call(self, arg1, arg2);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2);
  }
}
function emitThree(handler, isFn, self, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2, arg3);
  }
}

function emitMany(handler, isFn, self, args) {
  if (isFn)
    handler.apply(self, args);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].apply(self, args);
  }
}

EventEmitter.prototype.emit = function emit(type) {
  var er, handler, len, args, i, events, domain;
  var doError = (type === 'error');

  events = this._events;
  if (events)
    doError = (doError && events.error == null);
  else if (!doError)
    return false;

  domain = this.domain;

  // If there is no 'error' event listener then throw.
  if (doError) {
    er = arguments[1];
    if (domain) {
      if (!er)
        er = new Error('Uncaught, unspecified "error" event');
      er.domainEmitter = this;
      er.domain = domain;
      er.domainThrown = false;
      domain.emit('error', er);
    } else if (er instanceof Error) {
      throw er; // Unhandled 'error' event
    } else {
      // At least give some kind of context to the user
      var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
      err.context = er;
      throw err;
    }
    return false;
  }

  handler = events[type];

  if (!handler)
    return false;

  var isFn = typeof handler === 'function';
  len = arguments.length;
  switch (len) {
    // fast cases
    case 1:
      emitNone(handler, isFn, this);
      break;
    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
    // slower
    default:
      args = new Array(len - 1);
      for (i = 1; i < len; i++)
        args[i - 1] = arguments[i];
      emitMany(handler, isFn, this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');

  events = target._events;
  if (!events) {
    events = target._events = new EventHandlers();
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (!existing) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] = prepend ? [listener, existing] :
                                          [existing, listener];
    } else {
      // If we've already got an array, just append.
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }

    // Check for listener leak
    if (!existing.warned) {
      m = $getMaxListeners(target);
      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        var w = new Error('Possible EventEmitter memory leak detected. ' +
                            existing.length + ' ' + type + ' listeners added. ' +
                            'Use emitter.setMaxListeners() to increase limit');
        w.name = 'MaxListenersExceededWarning';
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        emitWarning(w);
      }
    }
  }

  return target;
}
function emitWarning(e) {
  typeof console.warn === 'function' ? console.warn(e) : console.log(e);
}
EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function _onceWrap(target, type, listener) {
  var fired = false;
  function g() {
    target.removeListener(type, g);
    if (!fired) {
      fired = true;
      listener.apply(target, arguments);
    }
  }
  g.listener = listener;
  return g;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');

      events = this._events;
      if (!events)
        return this;

      list = events[type];
      if (!list)
        return this;

      if (list === listener || (list.listener && list.listener === listener)) {
        if (--this._eventsCount === 0)
          this._events = new EventHandlers();
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length; i-- > 0;) {
          if (list[i] === listener ||
              (list[i].listener && list[i].listener === listener)) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (list.length === 1) {
          list[0] = undefined;
          if (--this._eventsCount === 0) {
            this._events = new EventHandlers();
            return this;
          } else {
            delete events[type];
          }
        } else {
          spliceOne(list, position);
        }

        if (events.removeListener)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };
    
// Alias for removeListener added in NodeJS 10.0
// https://nodejs.org/api/events.html#events_emitter_off_eventname_listener
EventEmitter.prototype.off = function(type, listener){
    return this.removeListener(type, listener);
};

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events;

      events = this._events;
      if (!events)
        return this;

      // not listening for removeListener, no need to emit
      if (!events.removeListener) {
        if (arguments.length === 0) {
          this._events = new EventHandlers();
          this._eventsCount = 0;
        } else if (events[type]) {
          if (--this._eventsCount === 0)
            this._events = new EventHandlers();
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        for (var i = 0, key; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = new EventHandlers();
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners) {
        // LIFO order
        do {
          this.removeListener(type, listeners[listeners.length - 1]);
        } while (listeners[0]);
      }

      return this;
    };

EventEmitter.prototype.listeners = function listeners(type) {
  var evlistener;
  var ret;
  var events = this._events;

  if (!events)
    ret = [];
  else {
    evlistener = events[type];
    if (!evlistener)
      ret = [];
    else if (typeof evlistener === 'function')
      ret = [evlistener.listener || evlistener];
    else
      ret = unwrapListeners(evlistener);
  }

  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};

// About 1.5x faster than the two-arg version of Array#splice().
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
    list[i] = list[k];
  list.pop();
}

function arrayClone(arr, i) {
  var copy = new Array(i);
  while (i--)
    copy[i] = arr[i];
  return copy;
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

/**
 * Construct URI with query parameters
 */
var UriBuilder = /*#__PURE__*/function () {
  function UriBuilder(base) {
    _classCallCheck__default['default'](this, UriBuilder);

    this.base = base;
    this.args = new Array();
    this.paths = new Array();
  }

  _createClass__default['default'](UriBuilder, [{
    key: "pathSegment",
    value: function pathSegment(name) {
      this.paths.push(encodeURIComponent(name));
      return this;
    }
  }, {
    key: "queryParam",
    value: function queryParam(name, value) {
      if (typeof value !== 'undefined') {
        this.args.push(encodeURIComponent(name) + '=' + encodeURIComponent(value));
      }

      return this;
    }
  }, {
    key: "build",
    value: function build() {
      var result = this.base;

      if (this.paths.length) {
        result += '/' + this.paths.join('/');
      }

      if (this.args.length) {
        result += '?' + this.args.join('&');
      }

      return result;
    }
  }]);

  return UriBuilder;
}();

function _createSuper$7(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$7(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

function _isNativeReflectConstruct$7() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

/**
 * Generic SyncLibrary error class
 */
var SyncError = /*#__PURE__*/function (_Error) {
  _inherits__default['default'](SyncError, _Error);

  var _super = _createSuper$7(SyncError);

  function SyncError(message) {
    var _this;

    var status = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var code = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

    _classCallCheck__default['default'](this, SyncError);

    _this = _super.call(this);
    _this.name = _this.constructor.name;
    _this.message = "".concat(message, " (status: ").concat(status, ", code: ").concat(code, ")");
    _this.status = status;
    _this.code = code;
    return _this;
  }

  return SyncError;
}( /*#__PURE__*/_wrapNativeSuper__default['default'](Error));

var SyncNetworkError = /*#__PURE__*/function (_SyncError) {
  _inherits__default['default'](SyncNetworkError, _SyncError);

  var _super2 = _createSuper$7(SyncNetworkError);

  function SyncNetworkError(message) {
    var _this2;

    var status = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var code = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var body = arguments.length > 3 ? arguments[3] : undefined;

    _classCallCheck__default['default'](this, SyncNetworkError);

    _this2 = _super2.call(this, message, status, code);
    _this2.body = body;
    return _this2;
  }

  return SyncNetworkError;
}(SyncError);

/**
 * Deep-clone an object. Note that this does not work on object containing
 * functions.
 * @param {object} obj - the object to deep-clone
 * @return {object}
 */

function deepClone(obj) {
  return JSON.parse(JSON.stringify(obj));
}

function validatePageSize(pageSize) {
  var validPageSize = pageSize === undefined || isPositiveInteger(pageSize);

  if (!validPageSize) {
    throw new SyncError("Invalid pageSize parameter. Expected a positive integer, was '".concat(pageSize, "'."), 400, 20007);
  }
}

function isInteger(number) {
  return !isNaN(parseInt(number)) && isFinite(number);
}

function isPositiveInteger(number) {
  return isInteger(number) && number > 0;
}

var log = loglevelLog__namespace.getLogger('twilio-sync'); // twilio-sync is used by Flex SDK. Please DO NOT change

function prepareLine(prefix, args) {
  return ["".concat(new Date().toISOString(), " Sync ").concat(prefix, ":")].concat(Array.from(args));
}

var log$1 = {
  setLevel: function setLevel(level) {
    log.setLevel(level);
  },
  trace: function trace() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    log.trace.apply(null, prepareLine('T', args));
  },
  debug: function debug() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    log.debug.apply(null, prepareLine('D', args));
  },
  info: function info() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }

    log.info.apply(null, prepareLine('I', args));
  },
  warn: function warn() {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }

    log.warn.apply(null, prepareLine('W', args));
  },
  error: function error() {
    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      args[_key5] = arguments[_key5];
    }

    log.error.apply(null, prepareLine('E', args));
  }
};

var SUBSCRIPTIONS_PATH = '/v4/Subscriptions';
var MAPS_PATH = '/v3/Maps';
var LISTS_PATH = '/v3/Lists';
var DOCUMENTS_PATH = '/v3/Documents';
var STREAMS_PATH = '/v3/Streams';
var INSIGHTS_PATH = '/v3/Insights';

function getWithDefault(container, key, defaultValue) {
  if (container && typeof container[key] !== 'undefined') {
    return container[key];
  }

  return defaultValue;
}
/**
 * Settings container for Sync library
 */


var Configuration = /*#__PURE__*/function () {
  /**
   * @param {Object} options
   */
  function Configuration() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck__default['default'](this, Configuration);

    var region = options.region || 'us1';
    var defaultCdsUrl = "https://cds.".concat(region, ".twilio.com");
    var baseUri = options.cdsUri || defaultCdsUrl;
    this.settings = {
      subscriptionsUri: baseUri + SUBSCRIPTIONS_PATH,
      documentsUri: baseUri + DOCUMENTS_PATH,
      listsUri: baseUri + LISTS_PATH,
      mapsUri: baseUri + MAPS_PATH,
      streamsUri: baseUri + STREAMS_PATH,
      insightsUri: baseUri + INSIGHTS_PATH,
      sessionStorageEnabled: getWithDefault(options.Sync, 'enableSessionStorage', true),
      productId: options.productId
    };
  }

  _createClass__default['default'](Configuration, [{
    key: "subscriptionsUri",
    get: function get() {
      return this.settings.subscriptionsUri;
    }
  }, {
    key: "documentsUri",
    get: function get() {
      return this.settings.documentsUri;
    }
  }, {
    key: "listsUri",
    get: function get() {
      return this.settings.listsUri;
    }
  }, {
    key: "mapsUri",
    get: function get() {
      return this.settings.mapsUri;
    }
  }, {
    key: "streamsUri",
    get: function get() {
      return this.settings.streamsUri;
    }
  }, {
    key: "insightsUri",
    get: function get() {
      return this.settings.insightsUri;
    }
  }, {
    key: "backoffConfig",
    get: function get() {
      return this.settings.backoffConfig || {};
    }
  }, {
    key: "sessionStorageEnabled",
    get: function get() {
      return this.settings.sessionStorageEnabled;
    }
  }, {
    key: "productId",
    get: function get() {
      return this.settings.productId;
    }
  }]);

  return Configuration;
}();

function _createForOfIteratorHelper$3(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$3(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray$3(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$3(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$3(o, minLen); }

function _arrayLikeToArray$3(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
/**
 * A data container used by the Subscriptions class to track subscribed entities' local
 * representations and their state.
 */

var SubscribedEntity = /*#__PURE__*/function () {
  function SubscribedEntity(entity) {
    _classCallCheck__default['default'](this, SubscribedEntity);

    this.localObject = entity;
    this.pendingCorrelationId = null;
    this.pendingAction = null;
    this.established = false;
    this.retryCount = 0;
  }

  _createClass__default['default'](SubscribedEntity, [{
    key: "sid",
    get: function get() {
      return this.localObject.sid;
    }
  }, {
    key: "type",
    get: function get() {
      return this.localObject.type;
    }
  }, {
    key: "lastEventId",
    get: function get() {
      return this.localObject.lastEventId;
    } // below properties are specific to Insights only

  }, {
    key: "indexName",
    get: function get() {
      return this.localObject.indexName;
    }
  }, {
    key: "queryString",
    get: function get() {
      return this.localObject.queryString;
    }
  }, {
    key: "isEstablished",
    get: function get() {
      return this.established;
    }
  }, {
    key: "update",
    value: function update(event, isStrictlyOrdered) {
      this.localObject._update(event, isStrictlyOrdered);
    }
  }, {
    key: "updatePending",
    value: function updatePending(action, correlationId) {
      this.pendingAction = action;
      this.pendingCorrelationId = correlationId;
    }
  }, {
    key: "reset",
    value: function reset() {
      this.updatePending(null, null);
      this.retryCount = 0;
      this.established = false;
      this.setSubscriptionState('none');
    }
  }, {
    key: "markAsFailed",
    value: function markAsFailed(message) {
      this.rejectedWithError = message.error;
      this.updatePending(null, null);
      this.localObject.reportFailure(new SyncError("Failed to subscribe on service events: ".concat(message.error.message), message.error.status, message.error.code));
    }
  }, {
    key: "complete",
    value: function complete(eventId) {
      this.updatePending(null, null);
      this.established = true;

      this.localObject._advanceLastEventId(eventId);
    }
  }, {
    key: "setSubscriptionState",
    value: function setSubscriptionState(newState) {
      this.localObject._setSubscriptionState(newState);
    }
  }]);

  return SubscribedEntity;
}();
/**
 * @class Subscriptions
 * @classdesc A manager which, in batches of varying size, continuously persists the
 *      subscription intent of the caller to the Sync backend until it achieves a
 *      converged state.
 */


var Subscriptions = /*#__PURE__*/function () {
  // This is always the full set of subscribables (SubscribedEntity instances) intended by
  // the client. At any point, whatever the state of these subscriptions on the server, this
  // is the intent of the user to which the SDK must converge.
  // This includes the set of subscribables (SubscribedEntity instances) for whom a request
  // has been dispatched (whether or not this particular request ultimately succeeds) to
  // establish a live subscription. Entities are removed when the corresponding "cancel"
  // request is dispatched.
  // If the server includes a `ttl_in_s` attribute in the poke response, subscriptionTtlTimer is started for that duration
  // such that when it fires, it repokes the entire sync set (i.e., emulates a reconnect). Every reconnect resets the timer.
  // After the timer has fired, the first poke request includes a `reason: ttl` attribute in the body.

  /**
   * @constructor
   * Prepares a new Subscriptions manager object with zero subscribed or persisted subscriptions.
   *
   * @param {object} config may include a key 'backoffConfig', wherein any of the parameters
   *      of Backoff.exponential (from npm 'backoff') are valid and will override the defaults.
   *
   * @param {Network} must be a viable running Sync Network object, useful for routing requests.
   */
  function Subscriptions(services) {
    var _this = this;

    _classCallCheck__default['default'](this, Subscriptions);

    _defineProperty__default['default'](this, "isConnected", false);

    _defineProperty__default['default'](this, "maxBatchSize", 100);

    _defineProperty__default['default'](this, "subscriptionTtlTimer", null);

    _defineProperty__default['default'](this, "pendingPokeReason", null);

    this.services = services;
    this.subscriptions = new Map();
    this.persisted = new Map();
    this.latestPokeResponseArrivalTimestampByCorrelationId = new Map();
    var defaultBackoffConfig = {
      randomisationFactor: 0.2,
      initialDelay: 100,
      maxDelay: 2 * 60 * 1000
    };
    this.backoff = operationRetrier.Backoff.exponential(Object.assign(defaultBackoffConfig, this.services.config.backoffConfig)); // This block is triggered by #_persist. Every request is executed in a series of (ideally 1)
    // backoff 'ready' event, at which point a new subscription set is calculated.

    this.backoff.on('ready', function () {
      var _this$getSubscription = _this.getSubscriptionUpdateBatch(),
          action = _this$getSubscription.action,
          subscriptionRequests = _this$getSubscription.subscriptions;

      if (action) {
        _this.applyNewSubscriptionUpdateBatch(action, subscriptionRequests);
      } else {
        _this.backoff.reset();

        log$1.debug('All subscriptions resolved.');
      }
    });
  }

  _createClass__default['default'](Subscriptions, [{
    key: "getSubscriptionUpdateBatch",
    value: function getSubscriptionUpdateBatch() {
      function subtract(these, those, action, limit) {
        var result = [];

        var _iterator = _createForOfIteratorHelper$3(these),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var _step$value = _slicedToArray__default['default'](_step.value, 2),
                thisKey = _step$value[0],
                thisValue = _step$value[1];

            var otherValue = those.get(thisKey);

            if (!otherValue && action !== thisValue.pendingAction && !thisValue.rejectedWithError) {
              result.push(thisValue);

              if (limit && result.length >= limit) {
                break;
              }
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        return result;
      }

      var listToAdd = subtract(this.subscriptions, this.persisted, 'establish', this.maxBatchSize);

      if (listToAdd.length > 0) {
        return {
          action: 'establish',
          subscriptions: listToAdd
        };
      }

      var listToRemove = subtract(this.persisted, this.subscriptions, 'cancel', this.maxBatchSize);

      if (listToRemove.length > 0) {
        return {
          action: 'cancel',
          subscriptions: listToRemove
        };
      }

      return {
        action: null,
        subscriptions: null
      };
    }
  }, {
    key: "persist",
    value: function persist() {
      this.backoff.backoff();
    }
  }, {
    key: "applyNewSubscriptionUpdateBatch",
    value: function () {
      var _applyNewSubscriptionUpdateBatch = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee(action, requests) {
        var _this2 = this;

        var correlationId, _iterator2, _step2, subscribed, reason, response, newMaxBatchSize, subscriptionTtlInS, isNumeric, isValidTtl, estimatedDeliveryInMs, _isNumeric, isValidTimeout, _iterator3, _step3, attemptedSubscription;

        return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (this.isConnected) {
                  _context.next = 4;
                  break;
                }

                log$1.debug("Twilsock connection (required for subscription) not ready; waiting\u2026");
                this.backoff.reset();
                return _context.abrupt("return");

              case 4:
                // Keeping in mind that events may begin flowing _before_ we receive the response
                requests = this.processLocalActions(action, requests);
                correlationId = new Date().getTime();
                _iterator2 = _createForOfIteratorHelper$3(requests);

                try {
                  for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                    subscribed = _step2.value;
                    this.recordActionAttemptOn(subscribed, action, correlationId);
                  }
                } catch (err) {
                  _iterator2.e(err);
                } finally {
                  _iterator2.f();
                }

                reason = this.pendingPokeReason;
                this.pendingPokeReason = null; // Send this batch to the service

                _context.prev = 10;
                _context.next = 13;
                return this.request(action, correlationId, reason, requests);

              case 13:
                response = _context.sent;
                newMaxBatchSize = response.body.max_batch_size;

                if (!isNaN(parseInt(newMaxBatchSize)) && isFinite(newMaxBatchSize) && newMaxBatchSize > 0) {
                  this.maxBatchSize = newMaxBatchSize;
                }

                if (!this.subscriptionTtlTimer) {
                  subscriptionTtlInS = response.body.ttl_in_s;
                  isNumeric = !isNaN(parseFloat(subscriptionTtlInS)) && isFinite(subscriptionTtlInS);
                  isValidTtl = isNumeric && subscriptionTtlInS > 0;

                  if (isValidTtl) {
                    this.subscriptionTtlTimer = setTimeout(function () {
                      return _this2.onSubscriptionTtlElapsed();
                    }, subscriptionTtlInS * 1000);
                  }
                }

                if (action === 'establish') {
                  estimatedDeliveryInMs = response.body.estimated_delivery_in_ms;
                  _isNumeric = !isNaN(parseFloat(estimatedDeliveryInMs)) && isFinite(estimatedDeliveryInMs);
                  isValidTimeout = _isNumeric && estimatedDeliveryInMs > 0;

                  if (isValidTimeout) {
                    setTimeout(function () {
                      return _this2.verifyPokeDelivery(correlationId, estimatedDeliveryInMs, requests);
                    }, estimatedDeliveryInMs);
                  } else {
                    log$1.error("Invalid timeout: ".concat(estimatedDeliveryInMs));
                  }

                  requests.filter(function (r) {
                    return r.pendingCorrelationId === correlationId;
                  }).forEach(function (r) {
                    return r.setSubscriptionState('response_in_flight');
                  });
                }

                this.backoff.reset();
                _context.next = 26;
                break;

              case 21:
                _context.prev = 21;
                _context.t0 = _context["catch"](10);
                _iterator3 = _createForOfIteratorHelper$3(requests);

                try {
                  for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                    attemptedSubscription = _step3.value;
                    this.recordActionFailureOn(attemptedSubscription, action);
                  }
                } catch (err) {
                  _iterator3.e(err);
                } finally {
                  _iterator3.f();
                }

                if (_context.t0 instanceof twilsock.TransportUnavailableError) {
                  log$1.debug("Twilsock connection (required for subscription) not ready (c:".concat(correlationId, "); waiting\u2026"));
                  this.backoff.reset();
                } else {
                  log$1.debug("Failed an attempt to ".concat(action, " subscriptions (c:").concat(correlationId, "); retrying"), _context.t0);
                  this.persist();
                }

              case 26:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[10, 21]]);
      }));

      function applyNewSubscriptionUpdateBatch(_x, _x2) {
        return _applyNewSubscriptionUpdateBatch.apply(this, arguments);
      }

      return applyNewSubscriptionUpdateBatch;
    }()
  }, {
    key: "verifyPokeDelivery",
    value: function verifyPokeDelivery(correlationId, estimatedDeliveryInMs, requests) {
      var _this3 = this;

      var lastReceived = this.latestPokeResponseArrivalTimestampByCorrelationId.get(correlationId);
      var silencePeriod = lastReceived ? new Date().getTime() - lastReceived : estimatedDeliveryInMs;

      if (silencePeriod >= estimatedDeliveryInMs) {
        // If we haven't received _any_ responses from that poke request for the duration of estimated_delivery_in_ms, poke again
        requests.filter(function (r) {
          return r.pendingCorrelationId === correlationId;
        }).forEach(function (r) {
          r.updatePending(null, null);
          r.retryCount++;

          _this3.persisted.delete(r.sid);
        });
        this.persist();
        this.latestPokeResponseArrivalTimestampByCorrelationId.delete(correlationId);
      } else {
        // Otherwise, the poke responses are probably in transit and we should wait for them
        var timeoutExtension = estimatedDeliveryInMs - silencePeriod;
        setTimeout(function () {
          return _this3.verifyPokeDelivery(correlationId, estimatedDeliveryInMs, requests);
        }, timeoutExtension);
      }
    }
  }, {
    key: "processLocalActions",
    value: function processLocalActions(action, requests) {
      if (action === 'cancel') {
        return requests.filter(function (request) {
          return !request.rejectedWithError;
        });
      }

      return requests;
    }
  }, {
    key: "recordActionAttemptOn",
    value: function recordActionAttemptOn(attemptedSubscription, action, correlationId) {
      attemptedSubscription.setSubscriptionState('request_in_flight');

      if (action === 'establish') {
        this.persisted.set(attemptedSubscription.sid, attemptedSubscription);
        attemptedSubscription.updatePending(action, correlationId);
      } else {
        // cancel
        var persistedSubscription = this.persisted.get(attemptedSubscription.sid);

        if (persistedSubscription) {
          persistedSubscription.updatePending(action, correlationId);
        }
      }
    }
  }, {
    key: "recordActionFailureOn",
    value: function recordActionFailureOn(attemptedSubscription, action) {
      attemptedSubscription.setSubscriptionState('none');
      attemptedSubscription.updatePending(null, null);

      if (action === 'establish') {
        this.persisted.delete(attemptedSubscription.sid);
      }
    }
  }, {
    key: "request",
    value: function request(action, correlationId, reason, objects) {
      var requests = objects.map(function (object) {
        return {
          object_sid: object.sid,
          object_type: object.type,
          last_event_id: action === 'establish' ? object.lastEventId : undefined,
          index_name: action === 'establish' ? object.indexName : undefined,
          query_string: action === 'establish' ? object.queryString : undefined
        };
      });
      var retriedRequests = objects.filter(function (a) {
        return a.retryCount > 0;
      }).length;
      log$1.debug("Attempting '".concat(action, "' request (c:").concat(correlationId, "):"), requests);
      var requestBody = {
        event_protocol_version: 4,
        action: action,
        correlation_id: correlationId,
        retried_requests: retriedRequests,
        ttl_in_s: -1,
        requests: requests
      };

      if (reason === 'ttl') {
        requestBody.reason = reason;
      }

      return this.services.network.post(this.services.config.subscriptionsUri, requestBody);
    }
    /**
     * Establishes intent to be subscribed to this entity. That subscription will be effected
     * asynchronously.
     * If subscription to the given sid already exists, it will be overwritten.
     *
     * @param {String} sid should be a well-formed SID, uniquely identifying a single instance of a Sync entity.
     * @param {Object} entity should represent the (singular) local representation of this entity.
     *      Incoming events and modifications to the entity will be directed at the _update() function
     *      of this provided reference.
     *
     * @return undefined
     */

  }, {
    key: "add",
    value: function add(sid, entity) {
      log$1.debug("Establishing intent to subscribe to ".concat(sid));
      var existingSubscription = this.subscriptions.get(sid);

      if (existingSubscription && entity && existingSubscription.lastEventId === entity.lastEventId) {
        // If last event id is the same as before - we're fine
        return;
      }

      this.persisted.delete(sid);
      this.subscriptions.set(sid, new SubscribedEntity(entity));
      this.persist();
    }
    /**
     * Establishes the caller's intent to no longer be subscribed to this entity. Following this
     * call, no further events shall be routed to the local representation of the entity, even
     * though a server-side subscription may take more time to actually terminate.
     *
     * @param {string} sid should be any well-formed SID, uniquely identifying a Sync entity.
     *      This call only has meaningful effect if that entity is subscribed at the
     *      time of call. Otherwise does nothing.
     *
     * @return undefined
     */

  }, {
    key: "remove",
    value: function remove(sid) {
      log$1.debug("Establishing intent to unsubscribe from ".concat(sid));
      var removed = this.subscriptions.delete(sid);

      if (removed) {
        this.persist();
      }
    }
    /**
     * The point of ingestion for remote incoming messages (e.g. new data was written to a map
     * to which we are subscribed).
     *
     * @param {object} message is the full, unaltered body of the incoming notification.
     *
     * @return undefined
     */

  }, {
    key: "acceptMessage",
    value: function acceptMessage(message, isStrictlyOrdered) {
      log$1.trace('Subscriptions received', message);
      var eventType = message.event_type;
      var events = typeof message.events !== 'undefined' ? message.events : [message.event];
      var correlationId = message.correlation_id;

      if (correlationId) {
        this.latestPokeResponseArrivalTimestampByCorrelationId.set(correlationId, new Date().getTime());
      }

      var _iterator4 = _createForOfIteratorHelper$3(events),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var event = _step4.value;
          var matchedEventType = void 0;

          switch (message.event_type) {
            case 'subscription_established':
              this.applySubscriptionEstablishedMessage(event, correlationId);
              break;

            case 'subscription_canceled':
              this.applySubscriptionCancelledMessage(event, correlationId);
              break;

            case 'subscription_failed':
              this.applySubscriptionFailedMessage(event, correlationId);
              break;

            case (matchedEventType = eventType.match(/^(?:map|list|document|stream|live_query)_/) || {}).input:
              {
                var typedSid = void 0;

                switch (matchedEventType[0]) {
                  case 'map_':
                    typedSid = event.map_sid;
                    break;

                  case 'list_':
                    typedSid = event.list_sid;
                    break;

                  case 'document_':
                    typedSid = event.document_sid;
                    break;

                  case 'stream_':
                    typedSid = event.stream_sid;
                    break;

                  case 'live_query_':
                    typedSid = event.query_id; // hack to mark replay events for LiveQuery as strictly ordered, due to lack of special type of notification for them
                    // (normally only replay events would have `twilio.sync.event` type, but LiveQuery non-replay events were also assigned
                    // to this type in legacy clients, which we have to support now; hence a hack)

                    isStrictlyOrdered = false; // explicitly override it due to code in router.ts does not know about LiveQueries

                    if (message.strictly_ordered === true) {
                      isStrictlyOrdered = true;
                    }

                    break;

                  default:
                    typedSid = undefined;
                }

                this.applyEventToSubscribedEntity(typedSid, event, eventType, isStrictlyOrdered);
                break;
              }

            default:
              log$1.debug("Dropping unknown message type ".concat(eventType));
              break;
          }
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
    }
  }, {
    key: "applySubscriptionEstablishedMessage",
    value: function applySubscriptionEstablishedMessage(message, correlationId) {
      var sid = message.object_sid;
      var subscriptionIntent = this.persisted.get(message.object_sid);

      if (subscriptionIntent && subscriptionIntent.pendingCorrelationId === correlationId) {
        if (message.replay_status === 'interrupted') {
          log$1.debug("Event Replay for subscription to ".concat(sid, " (c:").concat(correlationId, ") interrupted; continuing eagerly."));
          subscriptionIntent.updatePending(null, null);
          this.persisted.delete(subscriptionIntent.sid);
          this.backoff.reset();
        } else if (message.replay_status === 'completed') {
          log$1.debug("Event Replay for subscription to ".concat(sid, " (c:").concat(correlationId, ") completed. Subscription is ready."));
          subscriptionIntent.complete(message.last_event_id);
          this.persisted.set(message.object_sid, subscriptionIntent);
          subscriptionIntent.setSubscriptionState('established');
          this.backoff.reset();
        }
      } else {
        log$1.debug("Late message for ".concat(message.object_sid, " (c:").concat(correlationId, ") dropped."));
      }

      this.persist();
    }
  }, {
    key: "applySubscriptionCancelledMessage",
    value: function applySubscriptionCancelledMessage(message, correlationId) {
      var persistedSubscription = this.persisted.get(message.object_sid);

      if (persistedSubscription && persistedSubscription.pendingCorrelationId === correlationId) {
        persistedSubscription.updatePending(null, null);
        persistedSubscription.setSubscriptionState('none');
        this.persisted.delete(message.object_sid);
      } else {
        log$1.debug("Late message for ".concat(message.object_sid, " (c:").concat(correlationId, ") dropped."));
      }

      this.persist();
    }
  }, {
    key: "applySubscriptionFailedMessage",
    value: function applySubscriptionFailedMessage(message, correlationId) {
      var sid = message.object_sid;
      var subscriptionIntent = this.subscriptions.get(sid);
      var subscription = this.persisted.get(sid);

      if (subscriptionIntent && subscription) {
        if (subscription.pendingCorrelationId === correlationId) {
          log$1.error("Failed to subscribe on ".concat(subscription.sid), message.error);
          subscription.markAsFailed(message);
          subscription.setSubscriptionState('none');
        }
      } else if (!subscriptionIntent && subscription) {
        this.persisted.delete(sid);
        subscription.setSubscriptionState('none');
      }

      this.persist();
    }
  }, {
    key: "applyEventToSubscribedEntity",
    value: function applyEventToSubscribedEntity(sid, event, eventType, isStrictlyOrdered) {
      var _this4 = this;

      if (!sid) {
        return;
      } // Looking for subscription descriptor to check if poke has been completed


      isStrictlyOrdered = isStrictlyOrdered || function () {
        var subscription = _this4.persisted.get(sid);

        return subscription && subscription.isEstablished;
      }(); // Still searching for subscriptionIntents. User could remove subscription already


      var subscriptionIntent = this.subscriptions.get(sid);

      if (subscriptionIntent) {
        event.type = eventType;
        subscriptionIntent.update(event, isStrictlyOrdered);
      } else {
        log$1.debug("Message dropped for SID '".concat(sid, "', for which there is no subscription."));
      }
    }
  }, {
    key: "onConnectionStateChanged",
    value: function onConnectionStateChanged(isConnected) {
      this.isConnected = isConnected;

      if (isConnected) {
        this.poke('reconnect');
      }
    }
  }, {
    key: "onSubscriptionTtlElapsed",
    value: function onSubscriptionTtlElapsed() {
      if (this.isConnected) {
        this.poke('ttl');
      }
    }
    /**
     * Prompts a playback of any missed changes made to any subscribed object. This method
     * should be invoked whenever the connectivity layer has experienced cross-cutting
     * delivery failures that would affect the entire local sync set. Any tangible result
     * of this operation will result in calls to the _update() function of subscribed
     * Sync entities.
     */

  }, {
    key: "poke",
    value: function poke(reason) {
      log$1.debug("Triggering event replay for all subscriptions, reason=".concat(reason));
      this.pendingPokeReason = reason;

      if (this.subscriptionTtlTimer) {
        clearTimeout(this.subscriptionTtlTimer);
        this.subscriptionTtlTimer = null;
      }

      var failedSubscriptions = [];

      var _iterator5 = _createForOfIteratorHelper$3(this.persisted.values()),
          _step5;

      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var _it = _step5.value;

          _it.reset();

          if (_it.rejectedWithError) {
            failedSubscriptions.push(_it);
          }
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }

      this.persisted.clear();

      for (var _i = 0, _failedSubscriptions = failedSubscriptions; _i < _failedSubscriptions.length; _i++) {
        var it = _failedSubscriptions[_i];
        this.persisted.set(it.sid, it);
      }

      this.persist();
    }
    /**
     * Stops all communication, clears any subscription intent, and returns.
     */

  }, {
    key: "shutdown",
    value: function shutdown() {
      this.backoff.reset();
      this.subscriptions.clear();
    }
  }]);

  return Subscriptions;
}();

var MINIMUM_RETRY_DELAY = 4000;
var MAXIMUM_RETRY_DELAY = 60000;
var MAXIMUM_ATTEMPTS_TIME = 90000;
var RETRY_DELAY_RANDOMNESS = 0.2;

function messageFromErrorBody(transportError) {
  if (transportError.body) {
    if (transportError.body.message) {
      return transportError.body.message;
    }
  }

  switch (transportError.status) {
    case 429:
      return 'Throttled by server';

    case 404:
      return 'Not found from server';

    default:
      return 'Error from server';
  }
}

function codeFromErrorBody(trasportError) {
  if (trasportError.body) {
    return trasportError.body.code;
  }

  return 0;
}

function mapTransportError(transportError) {
  if (transportError.status === 409) {
    return new SyncNetworkError(messageFromErrorBody(transportError), transportError.status, codeFromErrorBody(transportError), transportError.body);
  } else if (transportError.status) {
    return new SyncError(messageFromErrorBody(transportError), transportError.status, codeFromErrorBody(transportError));
  } else if (transportError instanceof twilsock.TransportUnavailableError) {
    return transportError;
  } else {
    return new SyncError(transportError.message, 0, 0);
  }
}
/**
 * @classdesc Incapsulates network operations to make it possible to add some optimization/caching strategies
 */


var NetworkService = /*#__PURE__*/function () {
  function NetworkService(clientInfo, config, transport) {
    _classCallCheck__default['default'](this, NetworkService);

    this.clientInfo = clientInfo;
    this.config = config;
    this.transport = transport;
  }

  _createClass__default['default'](NetworkService, [{
    key: "createHeaders",
    value: function createHeaders() {
      return {
        'Content-Type': 'application/json',
        'Twilio-Sync-Client-Info': JSON.stringify(this.clientInfo),
        'Twilio-Request-Id': 'RQ' + uuid__namespace.v4().replace(/-/g, '')
      };
    }
  }, {
    key: "backoffConfig",
    value: function backoffConfig() {
      return Object.assign({
        min: MINIMUM_RETRY_DELAY,
        max: MAXIMUM_RETRY_DELAY,
        maxAttemptsTime: MAXIMUM_ATTEMPTS_TIME,
        randomness: RETRY_DELAY_RANDOMNESS
      }, this.config.backoffConfig);
    }
  }, {
    key: "executeWithRetry",
    value: function executeWithRetry(request) {
      var _this = this;

      var retryWhenThrottled = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      return new Promise(function (resolve, reject) {
        var codesToRetryOn = [502, 503, 504];

        if (retryWhenThrottled) {
          codesToRetryOn.push(429);
        }

        var retrier = new operationRetrier.Retrier(_this.backoffConfig());
        retrier.on('attempt', function () {
          request().then(function (result) {
            return retrier.succeeded(result);
          }).catch(function (err) {
            if (codesToRetryOn.includes(err.status)) {
              var delayOverride = parseInt(err.headers ? err.headers['Retry-After'] : null);
              retrier.failed(mapTransportError(err), isNaN(delayOverride) ? null : delayOverride * 1000);
            } else if (err.message === 'Twilsock disconnected') {
              // Ugly hack. We must make a proper exceptions for twilsock
              retrier.failed(mapTransportError(err));
            } else {
              // Fatal error
              retrier.removeAllListeners();
              retrier.cancel();
              reject(mapTransportError(err));
            }
          });
        });
        retrier.on('succeeded', function (result) {
          resolve(result);
        });
        retrier.on('cancelled', function (err) {
          return reject(mapTransportError(err));
        });
        retrier.on('failed', function (err) {
          return reject(mapTransportError(err));
        });
        retrier.start();
      });
    }
    /**
     * Make a GET request by given URI
     * @Returns Promise<Response> Result of successful get request
     */

  }, {
    key: "get",
    value: function get(uri) {
      var _this2 = this;

      var headers = this.createHeaders();
      log$1.debug('GET', uri, 'ID:', headers['Twilio-Request-Id']);
      return this.executeWithRetry(function () {
        return _this2.transport.get(uri, headers, _this2.config.productId);
      }, true);
    }
  }, {
    key: "post",
    value: function post(uri, body, revision) {
      var _this3 = this;

      var retryWhenThrottled = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      var headers = this.createHeaders();

      if (typeof revision !== 'undefined' && revision !== null) {
        headers['If-Match'] = revision;
      }

      log$1.debug('POST', uri, 'ID:', headers['Twilio-Request-Id']);
      return this.executeWithRetry(function () {
        return _this3.transport.post(uri, headers, body, _this3.config.productId);
      }, retryWhenThrottled);
    }
  }, {
    key: "put",
    value: function put(uri, body, revision) {
      var _this4 = this;

      var headers = this.createHeaders();

      if (typeof revision !== 'undefined' && revision !== null) {
        headers['If-Match'] = revision;
      }

      log$1.debug('PUT', uri, 'ID:', headers['Twilio-Request-Id']);
      return this.executeWithRetry(function () {
        return _this4.transport.put(uri, headers, body, _this4.config.productId);
      }, false);
    }
  }, {
    key: "delete",
    value: function _delete(uri) {
      var _this5 = this;

      var headers = this.createHeaders();
      log$1.debug('DELETE', uri, 'ID:', headers['Twilio-Request-Id']);
      return this.executeWithRetry(function () {
        return _this5.transport.delete(uri, headers, _this5.config.productId);
      }, false);
    }
  }]);

  return NetworkService;
}();

var SessionStorage = /*#__PURE__*/function () {
  function SessionStorage(config, storage) {
    _classCallCheck__default['default'](this, SessionStorage);

    this.config = config;
    this.storageId = null;

    try {
      this.storage = storage || sessionStorage;
    } catch (e) {}
  }

  _createClass__default['default'](SessionStorage, [{
    key: "storageKey",
    value: function storageKey(type, key) {
      return "".concat(this.storageId, "::").concat(type, "::").concat(key);
    }
  }, {
    key: "isReady",
    get: function get() {
      return this.config.sessionStorageEnabled && !!this.storageId;
    }
  }, {
    key: "updateStorageId",
    value: function updateStorageId(storageId) {
      this.storageId = storageId;
    }
  }, {
    key: "store",
    value: function store(type, id, value) {
      if (!this.isReady) {
        return null;
      }

      return this._store(this.storageKey(type, id), value);
    }
  }, {
    key: "read",
    value: function read(type, id) {
      if (!this.isReady) {
        return null;
      }

      return this._read(this.storageKey(type, id));
    }
  }, {
    key: "remove",
    value: function remove(type, sid, uniqueName) {
      if (!this.isReady) {
        return null;
      }

      try {
        this.storage.removeItem(this.storageKey(type, sid));

        if (uniqueName) {
          this.storage.removeItem(this.storageKey(type, uniqueName));
        }
      } catch (e) {}
    }
  }, {
    key: "update",
    value: function update(type, sid, uniqueName, patch) {
      if (!this.isReady) {
        return null;
      } // Currently cache may have root stored twice - by sid and by uniqueName
      // Maybe need to create some index if needed


      this._apply(this.storageKey(type, sid), patch);

      if (uniqueName) {
        this._apply(this.storageKey(type, uniqueName), patch);
      }
    }
  }, {
    key: "_store",
    value: function _store(key, value) {
      try {
        this.storage.setItem(key, JSON.stringify(value));
      } catch (e) {}
    }
  }, {
    key: "_read",
    value: function _read(key) {
      try {
        var storedData = this.storage.getItem(key);

        if (storedData) {
          return JSON.parse(storedData);
        }
      } catch (e) {}

      return null;
    }
  }, {
    key: "_apply",
    value: function _apply(key, patch) {
      var value = this._read(key);

      if (!value) {
        return false;
      }

      this._store(key, Object.assign(value, patch));
    }
  }]);

  return SessionStorage;
}();

function _createForOfIteratorHelper$2(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$2(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray$2(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$2(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$2(o, minLen); }

function _arrayLikeToArray$2(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var SyncEntity = /*#__PURE__*/function () {
  function SyncEntity(services, removalHandler) {
    _classCallCheck__default['default'](this, SyncEntity);

    this.services = services;
    this.removalHandler = removalHandler;
    this.subscriptionState = 'none';
    this._attachedListeners = new Map();
  }

  _createClass__default['default'](SyncEntity, [{
    key: "_advanceLastEventId",
    value: function _advanceLastEventId(eventId, revision) {}
  }, {
    key: "reportFailure",
    value: function reportFailure(err) {
      if (err.status === 404) {
        // assume that 404 means that entity has been removed while we were away
        this.onRemoved(false);
      } else {
        this.broadcastEventToListeners('failure', err);
      }
    }
    /**
     * Subscribe to changes of data entity
     * @private
     */

  }, {
    key: "_subscribe",
    value: function _subscribe() {
      this.services.router._subscribe(this.sid, this);
    }
    /**
     * Unsubscribe from changes of current data entity
     * @private
     */

  }, {
    key: "_unsubscribe",
    value: function _unsubscribe() {
      this.services.router._unsubscribe(this.sid);
    }
  }, {
    key: "_setSubscriptionState",
    value: function _setSubscriptionState(newState) {
      this.subscriptionState = newState;
      this.broadcastEventToListeners('_subscriptionStateChanged', newState);
    }
    /**
     * @public
     */

  }, {
    key: "close",
    value: function close() {
      this._unsubscribe();

      if (this.removalHandler != null) {
        this.removalHandler(this.type, this.sid, this.uniqueName);
      }
    }
  }, {
    key: "attach",
    value: function attach(closeable) {
      var uuid = closeable.listenerUuid;

      var existingRecord = this._attachedListeners.get(uuid);

      if (existingRecord) {
        return;
      }

      if (!this._attachedListeners.size) {
        // the first one to arrive
        this._subscribe();
      }

      this._attachedListeners.set(uuid, closeable);
    }
  }, {
    key: "detach",
    value: function detach(listenerUuid) {
      this._attachedListeners.delete(listenerUuid);

      if (!this._attachedListeners.size) {
        // last one out, turn off lights, shut the door
        this.close(); // invokes unsubscribe and removal handler
      }
    }
  }, {
    key: "broadcastEventToListeners",
    value: function broadcastEventToListeners(eventName, args) {
      var _iterator = _createForOfIteratorHelper$2(this._attachedListeners.values()),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var listener = _step.value;
          listener.emit(eventName, args);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  }]);

  return SyncEntity;
}();

var MergingQueue = /*#__PURE__*/function () {
  function MergingQueue(inputMergingFunction) {
    _classCallCheck__default['default'](this, MergingQueue);

    _defineProperty__default['default'](this, "queuedRequests", []);

    _defineProperty__default['default'](this, "isRequestInFlight", false);

    this.inputMergingFunction = inputMergingFunction;
  }

  _createClass__default['default'](MergingQueue, [{
    key: "add",
    value: function add(input, requestFunction) {
      var _this = this;

      var promise = new Promise(function (resolve, reject) {
        return _this.queuedRequests.push({
          input: input,
          requestFunction: requestFunction,
          resolve: resolve,
          reject: reject
        });
      });
      this.wakeupQueue();
      return promise;
    }
  }, {
    key: "squashAndAdd",
    value: function squashAndAdd(input, requestFunction) {
      var queueToSquash = this.queuedRequests;
      this.queuedRequests = [];
      var reducedInput;

      if (queueToSquash.length > 0) {
        reducedInput = queueToSquash.map(function (r) {
          return r.input;
        }).reduce(this.inputMergingFunction);
        reducedInput = this.inputMergingFunction(reducedInput, input);
      } else {
        reducedInput = input;
      }

      var promise = this.add(reducedInput, requestFunction);
      queueToSquash.forEach(function (request) {
        return promise.then(request.resolve, request.reject);
      });
      return promise;
    }
  }, {
    key: "isEmpty",
    value: function isEmpty() {
      return this.queuedRequests.length === 0 && !this.isRequestInFlight;
    }
  }, {
    key: "wakeupQueue",
    value: function wakeupQueue() {
      var _this2 = this;

      if (this.queuedRequests.length === 0 || this.isRequestInFlight) {
        return;
      } else {
        var requestToExecute = this.queuedRequests.shift();
        this.isRequestInFlight = true;
        requestToExecute.requestFunction(requestToExecute.input).then(requestToExecute.resolve, requestToExecute.reject).then(function (__) {
          _this2.isRequestInFlight = false;

          _this2.wakeupQueue();
        });
      }
    }
  }]);

  return MergingQueue;
}();
var NamespacedMergingQueue = /*#__PURE__*/function () {
  function NamespacedMergingQueue(inputReducer) {
    _classCallCheck__default['default'](this, NamespacedMergingQueue);

    _defineProperty__default['default'](this, "queueByNamespaceKey", new Map());

    this.inputReducer = inputReducer;
  }

  _createClass__default['default'](NamespacedMergingQueue, [{
    key: "add",
    value: function () {
      var _add = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee(namespaceKey, input, requestFunction) {
        return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", this.invokeQueueMethod(namespaceKey, function (queue) {
                  return queue.add(input, requestFunction);
                }));

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function add(_x, _x2, _x3) {
        return _add.apply(this, arguments);
      }

      return add;
    }()
  }, {
    key: "squashAndAdd",
    value: function () {
      var _squashAndAdd = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee2(namespaceKey, input, requestFunction) {
        return _regeneratorRuntime__default['default'].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                return _context2.abrupt("return", this.invokeQueueMethod(namespaceKey, function (queue) {
                  return queue.squashAndAdd(input, requestFunction);
                }));

              case 1:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function squashAndAdd(_x4, _x5, _x6) {
        return _squashAndAdd.apply(this, arguments);
      }

      return squashAndAdd;
    }()
  }, {
    key: "invokeQueueMethod",
    value: function () {
      var _invokeQueueMethod = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee3(namespaceKey, queueMethodInvoker) {
        var queue, result;
        return _regeneratorRuntime__default['default'].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (!this.queueByNamespaceKey.has(namespaceKey)) {
                  this.queueByNamespaceKey.set(namespaceKey, new MergingQueue(this.inputReducer));
                }

                queue = this.queueByNamespaceKey.get(namespaceKey);
                result = queueMethodInvoker(queue);

                if (this.queueByNamespaceKey.get(namespaceKey).isEmpty()) {
                  this.queueByNamespaceKey.delete(namespaceKey);
                }

                return _context3.abrupt("return", result);

              case 5:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function invokeQueueMethod(_x7, _x8) {
        return _invokeQueueMethod.apply(this, arguments);
      }

      return invokeQueueMethod;
    }()
  }]);

  return NamespacedMergingQueue;
}();

function _createSuper$6(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$6(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

function _isNativeReflectConstruct$6() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var Closeable = /*#__PURE__*/function (_EventEmitter) {
  _inherits__default['default'](Closeable, _EventEmitter);

  var _super = _createSuper$6(Closeable);

  function Closeable() {
    var _this;

    _classCallCheck__default['default'](this, Closeable);

    _this = _super.call(this);
    _this.closed = false;
    _this.uuid = uuid.v4();
    return _this;
  }

  _createClass__default['default'](Closeable, [{
    key: "listenerUuid",
    get: function get() {
      return this.uuid;
    }
  }, {
    key: "close",
    value: function close() {
      this.removeAllListeners();
      this.closed = true;
    }
  }, {
    key: "ensureNotClosed",
    value: function ensureNotClosed() {
      if (this.closed) {
        throw new Error('Invalid operation on closed object');
      }
    }
  }]);

  return Closeable;
}(EventEmitter);

function _createSuper$5(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$5(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

function _isNativeReflectConstruct$5() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var SyncDocumentImpl = /*#__PURE__*/function (_SyncEntity) {
  _inherits__default['default'](SyncDocumentImpl, _SyncEntity);

  var _super = _createSuper$5(SyncDocumentImpl);

  /**
   * @internal
   */
  function SyncDocumentImpl(services, descriptor, removalHandler) {
    var _this;

    _classCallCheck__default['default'](this, SyncDocumentImpl);

    _this = _super.call(this, services, removalHandler);

    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), "isDeleted", false);

    var updateRequestReducer = function updateRequestReducer(acc, input) {
      return typeof input.ttl === 'number' ? {
        ttl: input.ttl
      } : acc;
    };

    _this.updateMergingQueue = new MergingQueue(updateRequestReducer);
    _this.descriptor = descriptor;
    _this.descriptor.data = _this.descriptor.data || {};
    _this.descriptor.date_updated = new Date(_this.descriptor.date_updated);
    return _this;
  } // private props


  _createClass__default['default'](SyncDocumentImpl, [{
    key: "uri",
    get: function get() {
      return this.descriptor.url;
    }
  }, {
    key: "revision",
    get: function get() {
      return this.descriptor.revision;
    }
  }, {
    key: "lastEventId",
    get: function get() {
      return this.descriptor.last_event_id;
    }
  }, {
    key: "dateExpires",
    get: function get() {
      return this.descriptor.date_expires;
    }
  }, {
    key: "type",
    get: function get() {
      return 'document';
    } // below properties are specific to Insights only

  }, {
    key: "indexName",
    get: function get() {
      return undefined;
    }
  }, {
    key: "queryString",
    get: function get() {
      return undefined;
    } // public props, documented along with class description

  }, {
    key: "sid",
    get: function get() {
      return this.descriptor.sid;
    }
  }, {
    key: "data",
    get: function get() {
      return this.descriptor.data;
    }
  }, {
    key: "dateUpdated",
    get: function get() {
      return this.descriptor.date_updated;
    }
  }, {
    key: "uniqueName",
    get: function get() {
      return this.descriptor.unique_name || null;
    }
    /**
     * Update data entity with new data
     * @private
     */

  }, {
    key: "_update",
    value: function _update(update) {
      update.date_created = new Date(update.date_created);

      switch (update.type) {
        case 'document_updated':
          if (update.id <= this.lastEventId) {
            log$1.trace('Document update skipped, current:', this.lastEventId, ', remote:', update.id);
            break;
          }

          var previousData = this.descriptor.data !== undefined ? deepClone(this.descriptor.data) : null;
          this.descriptor.last_event_id = update.id;
          this.descriptor.revision = update.document_revision;
          this.descriptor.date_updated = update.date_created;
          this.descriptor.data = update.document_data;
          this.broadcastEventToListeners('updated', {
            data: update.document_data,
            isLocal: false,
            previousData: previousData
          });
          this.services.storage.update(this.type, this.sid, this.uniqueName, {
            last_event_id: update.id,
            revision: update.document_revision,
            date_updated: update.date_created,
            data: update.document_data
          });
          break;

        case 'document_removed':
          this.onRemoved(false);
          break;
      }
    }
  }, {
    key: "set",
    value: function () {
      var _set = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee(value, metadataUpdates) {
        var _this2 = this;

        var input;
        return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                input = metadataUpdates || {};
                return _context.abrupt("return", this.updateMergingQueue.squashAndAdd(input, function (input) {
                  return _this2._setUnconditionally(value, input.ttl);
                }));

              case 2:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function set(_x, _x2) {
        return _set.apply(this, arguments);
      }

      return set;
    }()
  }, {
    key: "mutate",
    value: function () {
      var _mutate = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee2(mutator, metadataUpdates) {
        var _this3 = this;

        var input;
        return _regeneratorRuntime__default['default'].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                input = metadataUpdates || {};
                return _context2.abrupt("return", this.updateMergingQueue.add(input, function (input) {
                  return _this3._setWithIfMatch(mutator, input.ttl);
                }));

              case 2:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function mutate(_x3, _x4) {
        return _mutate.apply(this, arguments);
      }

      return mutate;
    }()
  }, {
    key: "update",
    value: function () {
      var _update2 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee3(obj, metadataUpdates) {
        return _regeneratorRuntime__default['default'].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                return _context3.abrupt("return", this.mutate(function (remote) {
                  return Object.assign(remote, obj);
                }, metadataUpdates));

              case 1:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function update(_x5, _x6) {
        return _update2.apply(this, arguments);
      }

      return update;
    }()
  }, {
    key: "setTtl",
    value: function () {
      var _setTtl = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee4(ttl) {
        var response;
        return _regeneratorRuntime__default['default'].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this._postUpdateToServer({
                  ttl: ttl
                });

              case 2:
                response = _context4.sent;
                this.descriptor.date_expires = response.date_expires;

              case 4:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function setTtl(_x7) {
        return _setTtl.apply(this, arguments);
      }

      return setTtl;
    }()
    /**
     * @private
     */

  }, {
    key: "_setUnconditionally",
    value: function () {
      var _setUnconditionally2 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee5(value, ttl) {
        var result;
        return _regeneratorRuntime__default['default'].wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return this._postUpdateToServer({
                  data: value,
                  revision: undefined,
                  ttl: ttl
                });

              case 2:
                result = _context5.sent;

                this._handleSuccessfulUpdateResult(result);

                return _context5.abrupt("return", this.descriptor.data);

              case 5:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function _setUnconditionally(_x8, _x9) {
        return _setUnconditionally2.apply(this, arguments);
      }

      return _setUnconditionally;
    }()
    /**
     * @private
     */

  }, {
    key: "_setWithIfMatch",
    value: function () {
      var _setWithIfMatch2 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee6(mutatorFunction, ttl) {
        var data, revision, result;
        return _regeneratorRuntime__default['default'].wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                data = mutatorFunction(deepClone(this.descriptor.data));

                if (!data) {
                  _context6.next = 22;
                  break;
                }

                revision = this.revision;
                _context6.prev = 3;
                _context6.next = 6;
                return this._postUpdateToServer({
                  data: data,
                  revision: revision,
                  ttl: ttl
                });

              case 6:
                result = _context6.sent;

                this._handleSuccessfulUpdateResult(result);

                return _context6.abrupt("return", this.descriptor.data);

              case 11:
                _context6.prev = 11;
                _context6.t0 = _context6["catch"](3);

                if (!(_context6.t0.status === 412)) {
                  _context6.next = 19;
                  break;
                }

                _context6.next = 16;
                return this._softSync();

              case 16:
                return _context6.abrupt("return", this._setWithIfMatch(mutatorFunction));

              case 19:
                throw _context6.t0;

              case 20:
                _context6.next = 23;
                break;

              case 22:
                return _context6.abrupt("return", this.descriptor.data);

              case 23:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this, [[3, 11]]);
      }));

      function _setWithIfMatch(_x10, _x11) {
        return _setWithIfMatch2.apply(this, arguments);
      }

      return _setWithIfMatch;
    }()
    /**
     * @private
     */

  }, {
    key: "_handleSuccessfulUpdateResult",
    value: function _handleSuccessfulUpdateResult(result) {
      // Ignore returned value if we already got a newer one
      if (result.last_event_id <= this.descriptor.last_event_id) {
        return;
      }

      var previousData = this.descriptor.data !== undefined ? deepClone(this.descriptor.data) : null;
      this.descriptor.revision = result.revision;
      this.descriptor.data = result.data;
      this.descriptor.last_event_id = result.last_event_id;
      this.descriptor.date_expires = result.date_expires;
      this.descriptor.date_updated = new Date(result.date_updated);
      this.services.storage.update(this.type, this.sid, this.uniqueName, {
        last_event_id: result.last_event_id,
        revision: result.revision,
        date_updated: result.date_updated,
        data: result.data
      });
      this.broadcastEventToListeners('updated', {
        data: this.descriptor.data,
        isLocal: true,
        previousData: previousData
      });
    }
    /**
     * @private
     */

  }, {
    key: "_postUpdateToServer",
    value: function () {
      var _postUpdateToServer2 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee7(request) {
        var requestBody, ifMatch, response;
        return _regeneratorRuntime__default['default'].wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                if (this.isDeleted) {
                  _context7.next = 17;
                  break;
                }

                requestBody = {
                  data: request.data
                };

                if (request.ttl !== undefined) {
                  requestBody.ttl = request.ttl;
                }

                ifMatch = request.revision;
                _context7.prev = 4;
                _context7.next = 7;
                return this.services.network.post(this.uri, requestBody, ifMatch);

              case 7:
                response = _context7.sent;
                return _context7.abrupt("return", {
                  revision: response.body.revision,
                  data: request.data,
                  last_event_id: response.body.last_event_id,
                  date_updated: response.body.date_updated,
                  date_expires: response.body.date_expires
                });

              case 11:
                _context7.prev = 11;
                _context7.t0 = _context7["catch"](4);

                if (_context7.t0.status === 404) {
                  this.onRemoved(false);
                }

                throw _context7.t0;

              case 15:
                _context7.next = 18;
                break;

              case 17:
                return _context7.abrupt("return", Promise.reject(new SyncError('The Document has been removed', 404, 54100)));

              case 18:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this, [[4, 11]]);
      }));

      function _postUpdateToServer(_x12) {
        return _postUpdateToServer2.apply(this, arguments);
      }

      return _postUpdateToServer;
    }()
    /**
     * Get new data from server
     * @private
     */

  }, {
    key: "_softSync",
    value: function () {
      var _softSync2 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee8() {
        var _this4 = this;

        return _regeneratorRuntime__default['default'].wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                return _context8.abrupt("return", this.services.network.get(this.uri).then(function (response) {
                  var event = {
                    type: 'document_updated',
                    id: response.body.last_event_id,
                    document_revision: response.body.revision,
                    document_data: response.body.data,
                    date_created: response.body.date_updated
                  };

                  _this4._update(event);

                  return _this4;
                }).catch(function (err) {
                  if (err.status === 404) {
                    _this4.onRemoved(false);
                  } else {
                    log$1.error("Can't get updates for ".concat(_this4.sid, ":"), err);
                  }
                }));

              case 1:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function _softSync() {
        return _softSync2.apply(this, arguments);
      }

      return _softSync;
    }()
  }, {
    key: "onRemoved",
    value: function onRemoved(locally) {
      if (this.isDeleted) {
        return;
      }

      var previousData = this.descriptor.data !== undefined ? deepClone(this.descriptor.data) : null;
      this.isDeleted = true;

      this._unsubscribe();

      this.removalHandler(this.type, this.sid, this.uniqueName);
      this.broadcastEventToListeners('removed', {
        isLocal: locally,
        previousData: previousData
      });
    }
  }, {
    key: "removeDocument",
    value: function () {
      var _removeDocument = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee9() {
        return _regeneratorRuntime__default['default'].wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                if (this.isDeleted) {
                  _context9.next = 6;
                  break;
                }

                _context9.next = 3;
                return this.services.network.delete(this.uri);

              case 3:
                this.onRemoved(true);
                _context9.next = 7;
                break;

              case 6:
                return _context9.abrupt("return", Promise.reject(new SyncError('The Document has been removed', 404, 54100)));

              case 7:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function removeDocument() {
        return _removeDocument.apply(this, arguments);
      }

      return removeDocument;
    }()
  }], [{
    key: "type",
    get: function get() {
      return 'document';
    }
  }]);

  return SyncDocumentImpl;
}(SyncEntity);
/**
 * Represents a Sync document, the contents of which is a single JSON object.
 * Use the {@link SyncClient.document} method to obtain a reference to a Sync document.
 * Information about rate limits can be found [here](https://www.twilio.com/docs/sync/limits).
 */


var SyncDocument = /*#__PURE__*/function (_Closeable) {
  _inherits__default['default'](SyncDocument, _Closeable);

  var _super2 = _createSuper$5(SyncDocument);

  /**
   * @internal
   */
  function SyncDocument(syncDocumentImpl) {
    var _this5;

    _classCallCheck__default['default'](this, SyncDocument);

    _this5 = _super2.call(this);
    _this5.syncDocumentImpl = syncDocumentImpl;

    _this5.syncDocumentImpl.attach(_assertThisInitialized__default['default'](_this5));

    return _this5;
  }
  /**
   * Fired when the document is removed, regardless of whether the remover was local or remote.
   *
   * Parameters:
   * 1. object `args` - info object provided with the event. It has following properties:
   *     * boolean `isLocal` - is true if document was removed by a local actor, false otherwise
   *     * object `previousData` - contains a snapshot of the document data before removal
   * @example
   * ```typescript
   * document.on('removed', (args) => {
   *   console.log(`Document ${document.sid} was removed`);
   *   console.log('args.isLocal:', args.isLocal);
   *   console.log('args.previousData:', args.previousData);
   * });
   * ```
   * @event
   */


  _createClass__default['default'](SyncDocument, [{
    key: "uri",
    get: // private props
    function get() {
      return this.syncDocumentImpl.uri;
    }
  }, {
    key: "revision",
    get: function get() {
      return this.syncDocumentImpl.revision;
    }
  }, {
    key: "lastEventId",
    get: function get() {
      return this.syncDocumentImpl.lastEventId;
    }
  }, {
    key: "dateExpires",
    get: function get() {
      return this.syncDocumentImpl.dateExpires;
    }
  }, {
    key: "type",
    get: function get() {
      return SyncDocumentImpl.type;
    }
    /**
     * The immutable identifier of this document, assigned by the system.
     */

  }, {
    key: "sid",
    get: function get() {
      return this.syncDocumentImpl.sid;
    }
    /**
     * The contents of this document.
     */

  }, {
    key: "data",
    get: function get() {
      return this.syncDocumentImpl.data;
    }
    /**
     * Date when the document was last updated.
     */

  }, {
    key: "dateUpdated",
    get: function get() {
      return this.syncDocumentImpl.dateUpdated;
    }
    /**
     * An optional immutable identifier that may be assigned by the programmer
     * to this document during creation. Globally unique among other documents.
     */

  }, {
    key: "uniqueName",
    get: function get() {
      return this.syncDocumentImpl.uniqueName;
    }
  }, {
    key: "set",
    value:
    /**
     * Assign new contents to this document. The current data will be overwritten.
     * @param data The new contents to assign.
     * @param metadataUpdates New document metadata.
     * @return A promise resolving to the new data of the document.
     * @example
     * ```typescript
     * // Say, the Document data is `{ name: 'John Smith', age: 34 }`
     * document.set({ name: 'Barbara Oaks' }, { ttl: 86400 })
     *   .then((newValue) => {
     *     // Now the Document data is `{ name: 'Barbara Oaks' }`
     *     console.log('Document set() successful, new data:', newValue);
     *   })
     *   .catch((error) => {
     *     console.error('Document set() failed', error);
     *   });
     * ```
     */
    function () {
      var _set2 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee10(data, metadataUpdates) {
        return _regeneratorRuntime__default['default'].wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                this.ensureNotClosed();
                return _context10.abrupt("return", this.syncDocumentImpl.set(data, metadataUpdates));

              case 2:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function set(_x13, _x14) {
        return _set2.apply(this, arguments);
      }

      return set;
    }()
    /**
     * Schedules a modification to this document that will apply a mutation function.
     * @param mutator A function that outputs new data based on the existing data.
     * May be called multiple times, particularly if this document is modified concurrently by remote code.
     * If the mutation ultimately succeeds, the document will have made the particular transition described
     * by this function.
     * @param metadataUpdates New document metadata.
     * @return Resolves with the most recent Document state, whether the output of a
     * successful mutation or a state that prompted graceful cancellation (mutator returned `null`).
     * @example
     * ```typescript
     * const mutatorFunction = (currentValue) => {
     *     currentValue.viewCount = (currentValue.viewCount ?? 0) + 1;
     *     return currentValue;
     * };
     * document.mutate(mutatorFunction, { ttl: 86400 }))
     *   .then((newValue) => {
     *     console.log('Document mutate() successful, new data:', newValue);
     *   })
     *   .catch((error) => {
     *     console.error('Document mutate() failed', error);
     *   });
     * ```
     */

  }, {
    key: "mutate",
    value: function () {
      var _mutate2 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee11(mutator, metadataUpdates) {
        return _regeneratorRuntime__default['default'].wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                this.ensureNotClosed();
                return _context11.abrupt("return", this.syncDocumentImpl.mutate(mutator, metadataUpdates));

              case 2:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function mutate(_x15, _x16) {
        return _mutate2.apply(this, arguments);
      }

      return mutate;
    }()
    /**
     * Modify a document by appending new fields (or by overwriting existing ones) with the values from the provided Object.
     * This is equivalent to:
     * ```typescript
     * document.mutate((currentValue) => Object.assign(currentValue, obj));
     * ```
     * @param obj Specifies the particular (top-level) attributes that will receive new values.
     * @param metadataUpdates New document metadata.
     * @return A promise resolving to the new data of the document.
     * @example
     * ```typescript
     * // Say, the Document data is `{ name: 'John Smith' }`
     * document.update({ age: 34 }, { ttl: 86400 })
     *   .then((newValue) => {
     *     // Now the Document data is `{ name: 'John Smith', age: 34 }`
     *     console.log('Document update() successful, new data:', newValue);
     *   })
     *   .catch((error) => {
     *     console.error('Document update() failed', error);
     *   });
     * ```
     */

  }, {
    key: "update",
    value: function () {
      var _update3 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee12(obj, metadataUpdates) {
        return _regeneratorRuntime__default['default'].wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                this.ensureNotClosed();
                return _context12.abrupt("return", this.syncDocumentImpl.update(obj, metadataUpdates));

              case 2:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function update(_x17, _x18) {
        return _update3.apply(this, arguments);
      }

      return update;
    }()
    /**
     * Update the time-to-live of the document.
     * @param ttl Specifies the time-to-live in seconds after which the document is subject to automatic deletion. The value 0 means infinity.
     * @return A promise that resolves after the TTL update was successful.
     * @example
     * ```typescript
     * document.setTtl(3600)
     *   .then(() => {
     *     console.log('Document setTtl() successful');
     *   })
     *   .catch((error) => {
     *     console.error('Document setTtl() failed', error);
     *   });
     * ```
     */

  }, {
    key: "setTtl",
    value: function () {
      var _setTtl2 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee13(ttl) {
        return _regeneratorRuntime__default['default'].wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                this.ensureNotClosed();
                return _context13.abrupt("return", this.syncDocumentImpl.setTtl(ttl));

              case 2:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function setTtl(_x19) {
        return _setTtl2.apply(this, arguments);
      }

      return setTtl;
    }()
    /**
     * Delete a document.
     * @return A promise which resolves if (and only if) the document is ultimately deleted.
     * @example
     * ```typescript
     * document.removeDocument()
     *   .then(() => {
     *     console.log('Document removeDocument() successful');
     *   })
     *   .catch((error) => {
     *     console.error('Document removeDocument() failed', error);
     *   });
     * ```
     */

  }, {
    key: "removeDocument",
    value: function () {
      var _removeDocument2 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee14() {
        return _regeneratorRuntime__default['default'].wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                this.ensureNotClosed();
                return _context14.abrupt("return", this.syncDocumentImpl.removeDocument());

              case 2:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function removeDocument() {
        return _removeDocument2.apply(this, arguments);
      }

      return removeDocument;
    }()
    /**
     * Conclude work with the document instance and remove all event listeners attached to it.
     * Any subsequent operation on this object will be rejected with error.
     * Other local copies of this document will continue operating and receiving events normally.
     * @example
     * ```typescript
     * document.close();
     * ```
     */

  }, {
    key: "close",
    value: function close() {
      _get__default['default'](_getPrototypeOf__default['default'](SyncDocument.prototype), "close", this).call(this);

      this.syncDocumentImpl.detach(this.listenerUuid);
    }
  }], [{
    key: "type",
    get: function get() {
      return SyncDocumentImpl.type;
    }
  }]);

  return SyncDocument;
}(Closeable);

_defineProperty__default['default'](SyncDocument, "removed", 'removed');

_defineProperty__default['default'](SyncDocument, "updated", 'updated');

__decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.pureObject, ['undefined', declarativeTypeValidator.objectSchema('document metadata', {
  ttl: [declarativeTypeValidator.nonNegativeInteger, 'undefined']
})]), __metadata("design:type", Function), __metadata("design:paramtypes", [Object, Object]), __metadata("design:returntype", Promise)], SyncDocument.prototype, "set", null);

__decorate([declarativeTypeValidator.validateTypesAsync('function', ['undefined', declarativeTypeValidator.objectSchema('document metadata', {
  ttl: [declarativeTypeValidator.nonNegativeInteger, 'undefined']
})]), __metadata("design:type", Function), __metadata("design:paramtypes", [Function, Object]), __metadata("design:returntype", Promise)], SyncDocument.prototype, "mutate", null);

__decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.pureObject, ['undefined', declarativeTypeValidator.objectSchema('document metadata', {
  ttl: [declarativeTypeValidator.nonNegativeInteger, 'undefined']
})]), __metadata("design:type", Function), __metadata("design:paramtypes", [Object, Object]), __metadata("design:returntype", Promise)], SyncDocument.prototype, "update", null);

__decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonNegativeInteger), __metadata("design:type", Function), __metadata("design:paramtypes", [Number]), __metadata("design:returntype", Promise)], SyncDocument.prototype, "setTtl", null);

/**
 * Represents an individual element in a Sync list.
 */
var SyncListItem = /*#__PURE__*/function () {
  /**
   * @param descriptor Item descriptor
   * @internal
   */
  function SyncListItem(descriptor) {
    _classCallCheck__default['default'](this, SyncListItem);

    this.descriptor = descriptor;
  }

  _createClass__default['default'](SyncListItem, [{
    key: "uri",
    get: function get() {
      return this.descriptor.uri;
    }
  }, {
    key: "revision",
    get: function get() {
      return this.descriptor.revision;
    }
  }, {
    key: "lastEventId",
    get: function get() {
      return this.descriptor.lastEventId;
    }
    /**
     * Date when the list item was last updated.
     */

  }, {
    key: "dateUpdated",
    get: function get() {
      return this.descriptor.dateUpdated;
    }
  }, {
    key: "dateExpires",
    get: function get() {
      return this.descriptor.dateExpires;
    }
    /**
     * The index, within the containing list, of this item. This index is stable;
     * even if lower-indexed items are removed, this index will remain as is.
     */

  }, {
    key: "index",
    get: function get() {
      return this.descriptor.index;
    }
    /**
     * The contents of the item.
     */

  }, {
    key: "data",
    get: function get() {
      return this.descriptor.data;
    }
    /**
     * @internal
     */

  }, {
    key: "update",
    value: function update(eventId, revision, data, dateUpdated) {
      this.descriptor.lastEventId = eventId;
      this.descriptor.revision = revision;
      this.descriptor.data = data;
      this.descriptor.dateUpdated = dateUpdated;
      return this;
    }
    /**
     * @internal
     */

  }, {
    key: "updateDateExpires",
    value: function updateDateExpires(dateExpires) {
      this.descriptor.dateExpires = dateExpires;
    }
  }]);

  return SyncListItem;
}();

/**
 * Pagination helper class.
 */
var Paginator = /*#__PURE__*/function () {
  /**
   * Array of elements on current page.
   */

  /**
   * @internal
   */
  function Paginator(items, source, prevToken, nextToken) {
    _classCallCheck__default['default'](this, Paginator);

    this.prevToken = prevToken;
    this.nextToken = nextToken;
    this.items = items;
    this.source = source;
  }
  /**
   * Indicates the existence of the next page.
   */


  _createClass__default['default'](Paginator, [{
    key: "hasNextPage",
    get: function get() {
      return !!this.nextToken;
    }
    /**
     * Indicates the existence of the previous page.
     */

  }, {
    key: "hasPrevPage",
    get: function get() {
      return !!this.prevToken;
    }
    /**
     * Request next page.
     * Does not modify existing object.
     */

  }, {
    key: "nextPage",
    value: function () {
      var _nextPage = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee() {
        return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (this.hasNextPage) {
                  _context.next = 2;
                  break;
                }

                throw new Error('No next page');

              case 2:
                return _context.abrupt("return", this.source(this.nextToken));

              case 3:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function nextPage() {
        return _nextPage.apply(this, arguments);
      }

      return nextPage;
    }()
    /**
     * Request previous page.
     * Does not modify existing object.
     */

  }, {
    key: "prevPage",
    value: function () {
      var _prevPage = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee2() {
        return _regeneratorRuntime__default['default'].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (this.hasPrevPage) {
                  _context2.next = 2;
                  break;
                }

                throw new Error('No previous page');

              case 2:
                return _context2.abrupt("return", this.source(this.prevToken));

              case 3:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function prevPage() {
        return _prevPage.apply(this, arguments);
      }

      return prevPage;
    }()
  }]);

  return Paginator;
}();

function _createForOfIteratorHelper$1(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray$1(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$1(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen); }

function _arrayLikeToArray$1(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var Node = /*#__PURE__*/function () {
  function Node(key, value) {
    _classCallCheck__default['default'](this, Node);

    this.balanceFactor = 0;
    this.key = key;
    this.value = value;
    this.parent = null;
    this.left = null;
    this.right = null;
  }

  _createClass__default['default'](Node, [{
    key: "isRoot",
    get: function get() {
      return this.parent === null;
    }
  }, {
    key: "isLeaf",
    get: function get() {
      return this.left === null && this.right === null;
    }
  }, {
    key: "isLeftChild",
    get: function get() {
      return this.parent.left === this;
    }
  }, {
    key: "update",
    value: function update(value) {
      this.value = value;
    }
  }, {
    key: "replace",
    value: function replace(target, replacement) {
      if (!target) {
        return;
      }

      if (this.left === replacement) {
        this.left = replacement;
      } else if (this.right === replacement) {
        this.right = replacement;
      }
    }
  }]);

  return Node;
}();
/**
 * @property length
 */


var TreeMap = /*#__PURE__*/function () {
  function TreeMap(less, equal) {
    _classCallCheck__default['default'](this, TreeMap);

    this.isLessThan = less || function (x, y) {
      return x < y;
    };

    this.isEqual = equal || function (x, y) {
      return x === y;
    };

    this.root = null;
    this.count = null;
  }

  _createClass__default['default'](TreeMap, [{
    key: "size",
    get: function get() {
      return this.count;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.root = null;
      this.count = 0;
    }
  }, {
    key: "set",
    value: function set(key, value) {
      var node = this.getNode(key);

      if (node) {
        node.update(value);
      } else {
        this.insert(key, value);
      } // return node;

    }
  }, {
    key: "insert",
    value: function insert(key, value) {
      var node = new Node(key, value);
      this.count++;

      if (!this.root) {
        this.root = node; // return node;

        return;
      }

      var currNode = this.root;

      for (;;) {
        if (this.isLessThan(key, currNode.key)) {
          if (currNode.left) {
            currNode = currNode.left;
          } else {
            currNode.left = node;
            break;
          }
        } else {
          if (currNode.right) {
            // eslint-disable-line no-lonely-if
            currNode = currNode.right;
          } else {
            currNode.right = node;
            break;
          }
        }
      }

      node.parent = currNode;
      currNode = node;

      while (currNode.parent) {
        var parent = currNode.parent;
        var prevBalanceFactor = parent.balanceFactor;

        if (currNode.isLeftChild) {
          parent.balanceFactor++;
        } else {
          parent.balanceFactor--;
        }

        if (Math.abs(parent.balanceFactor) < Math.abs(prevBalanceFactor)) {
          break;
        }

        if (parent.balanceFactor < -1 || parent.balanceFactor > 1) {
          this.rebalance(parent);
          break;
        }

        currNode = parent;
      } // return node;

    }
  }, {
    key: "get",
    value: function get(key) {
      var currentNode = this.root;

      while (currentNode) {
        if (this.isEqual(key, currentNode.key)) {
          return currentNode.value;
        }

        if (this.isLessThan(key, currentNode.key)) {
          currentNode = currentNode.left;
        } else {
          currentNode = currentNode.right;
        }
      }

      return null;
    }
  }, {
    key: "delete",
    value: function _delete(key) {
      // update this algorithm and remove any
      var node = this.getNode(key);

      if (!node || node.key !== key) {
        return null;
      }

      var parent = node.parent;
      var left = node.left;
      var right = node.right;

      if (!!left !== !!right) {
        // one child
        var child = left || right;

        if (!parent && !child) {
          this.root = null;
        } else if (parent && !child) {
          this.root = child;
        } else {
          parent.replace(node, null);
          this.rebalance(parent);
        }
      } else {
        // two children
        var maxLeft = node.left;

        while (maxLeft.right) {
          maxLeft = maxLeft.right;
        }

        if (node.left === maxLeft) {
          if (node.isRoot) {
            this.root = maxLeft;
            maxLeft.parent = null;
          } else {
            if (node.isLeftChild) {
              node.parent.left = maxLeft;
            } else {
              node.parent.right = maxLeft;
            }

            maxLeft.parent = node.parent;
          }

          maxLeft.right = node.right;
          maxLeft.right.parent = maxLeft;
          maxLeft.balanceFactor = node.balanceFactor;
          node = {
            parent: maxLeft,
            isLeftChild: true
          };
        } else {
          var mlParent = maxLeft.parent;
          var mlLeft = maxLeft.left;
          mlParent.right = mlLeft;

          if (mlLeft) {
            mlLeft.parent = mlParent;
          }

          if (node.isRoot) {
            this.root = maxLeft;
            maxLeft.parent = null;
          } else {
            if (node.isLeftChild) {
              node.parent.left = maxLeft;
            } else {
              node.parent.right = maxLeft;
            }

            maxLeft.parent = node.parent;
          }

          maxLeft.right = node.right;
          maxLeft.right.parent = maxLeft;
          maxLeft.left = node.left;
          maxLeft.left.parent = maxLeft;
          maxLeft.balanceFactor = node.balanceFactor;
          node = {
            parent: mlParent,
            isLeftChild: false
          };
        }
      }

      this.count--;

      while (node.parent) {
        var _parent = node.parent;
        var prevBalanceFactor = _parent.balanceFactor;

        if (node.isLeftChild) {
          _parent.balanceFactor -= 1;
        } else {
          _parent.balanceFactor += 1;
        }

        if (Math.abs(_parent.balanceFactor) > Math.abs(prevBalanceFactor)) {
          if (_parent.balanceFactor < -1 || _parent.balanceFactor > 1) {
            this.rebalance(_parent);

            if (_parent.parent.balanceFactor === 0) {
              node = _parent.parent;
            } else {
              break;
            }
          } else {
            break;
          }
        } else {
          node = _parent;
        }
      }

      return null;
    }
  }, {
    key: "getNode",
    value: function getNode(key) {
      var currentNode = this.root;

      while (currentNode) {
        if (this.isEqual(key, currentNode.key)) {
          return currentNode;
        }

        if (this.isLessThan(key, currentNode.key)) {
          currentNode = currentNode.left;
        } else {
          currentNode = currentNode.right;
        }
      }

      return null;
    }
  }, {
    key: "rebalance",
    value: function rebalance(node) {
      if (node.balanceFactor < 0) {
        if (node.right.balanceFactor > 0) {
          this.rotateRight(node.right);
          this.rotateLeft(node);
        } else {
          this.rotateLeft(node);
        }
      } else if (node.balanceFactor > 0) {
        if (node.left.balanceFactor < 0) {
          this.rotateLeft(node.left);
          this.rotateRight(node);
        } else {
          this.rotateRight(node);
        }
      }
    }
  }, {
    key: "rotateLeft",
    value: function rotateLeft(pivot) {
      var root = pivot.right;
      pivot.right = root.left;

      if (root.left !== null) {
        root.left.parent = pivot;
      }

      root.parent = pivot.parent;

      if (root.parent === null) {
        this.root = root;
      } else if (pivot.isLeftChild) {
        root.parent.left = root;
      } else {
        root.parent.right = root;
      }

      root.left = pivot;
      pivot.parent = root;
      pivot.balanceFactor = pivot.balanceFactor + 1 - Math.min(root.balanceFactor, 0);
      root.balanceFactor = root.balanceFactor + 1 - Math.max(pivot.balanceFactor, 0);
    }
  }, {
    key: "rotateRight",
    value: function rotateRight(pivot) {
      var root = pivot.left;
      pivot.left = root.right;

      if (root.right !== null) {
        root.right.parent = pivot;
      }

      root.parent = pivot.parent;

      if (root.parent === null) {
        this.root = root;
      } else if (pivot.isLeftChild) {
        root.parent.left = root;
      } else {
        root.parent.right = root;
      }

      root.right = pivot;
      pivot.parent = root;
      pivot.balanceFactor = pivot.balanceFactor - 1 - Math.min(root.balanceFactor, 0);
      root.balanceFactor = root.balanceFactor - 1 - Math.max(pivot.balanceFactor, 0);
    }
  }, {
    key: Symbol.iterator,
    value: /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function value() {
      var _iterator, _step, iter;

      return _regeneratorRuntime__default['default'].wrap(function value$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _iterator = _createForOfIteratorHelper$1(this.getIterator());
              _context.prev = 1;

              _iterator.s();

            case 3:
              if ((_step = _iterator.n()).done) {
                _context.next = 9;
                break;
              }

              iter = _step.value;
              _context.next = 7;
              return iter;

            case 7:
              _context.next = 3;
              break;

            case 9:
              _context.next = 14;
              break;

            case 11:
              _context.prev = 11;
              _context.t0 = _context["catch"](1);

              _iterator.e(_context.t0);

            case 14:
              _context.prev = 14;

              _iterator.f();

              return _context.finish(14);

            case 17:
            case "end":
              return _context.stop();
          }
        }
      }, value, this, [[1, 11, 14, 17]]);
    })
  }, {
    key: "getIterator",
    value: /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function getIterator() {
      var key,
          currentNode,
          fromleft,
          _args2 = arguments;
      return _regeneratorRuntime__default['default'].wrap(function getIterator$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              key = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : null;
              currentNode = this.root;

            case 2:
              if (!currentNode) {
                _context2.next = 8;
                break;
              }

              if (!(this.isEqual(key, currentNode.key) || key === null && !currentNode.left)) {
                _context2.next = 5;
                break;
              }

              return _context2.abrupt("break", 8);

            case 5:
              if (this.isLessThan(key, currentNode.key) || key === null) {
                currentNode = currentNode.left;
              } else {
                currentNode = currentNode.right;
              }

              _context2.next = 2;
              break;

            case 8:
              if (currentNode) {
                _context2.next = 10;
                break;
              }

              return _context2.abrupt("return", null);

            case 10:
              fromleft = true;

            case 11:
              if (!fromleft) {
                _context2.next = 29;
                break;
              }

              _context2.next = 14;
              return [currentNode.key, currentNode.value];

            case 14:
              fromleft = false;

              if (!currentNode.right) {
                _context2.next = 21;
                break;
              }

              currentNode = currentNode.right;

              while (currentNode.left) {
                currentNode = currentNode.left;
              }

              fromleft = true;
              _context2.next = 27;
              break;

            case 21:
              if (!currentNode.parent) {
                _context2.next = 26;
                break;
              }

              fromleft = currentNode.parent.left === currentNode;
              currentNode = currentNode.parent;
              _context2.next = 27;
              break;

            case 26:
              return _context2.abrupt("break", 37);

            case 27:
              _context2.next = 35;
              break;

            case 29:
              if (!currentNode.parent) {
                _context2.next = 34;
                break;
              }

              fromleft = currentNode.parent.left === currentNode;
              currentNode = currentNode.parent;
              _context2.next = 35;
              break;

            case 34:
              return _context2.abrupt("break", 37);

            case 35:
              _context2.next = 11;
              break;

            case 37:
              return _context2.abrupt("return", null);

            case 38:
            case "end":
              return _context2.stop();
          }
        }
      }, getIterator, this);
    })
  }, {
    key: "getReverseIterator",
    value: /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function getReverseIterator() {
      var key,
          currentNode,
          fromright,
          _args3 = arguments;
      return _regeneratorRuntime__default['default'].wrap(function getReverseIterator$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              key = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : null;
              currentNode = this.root;

            case 2:
              if (!currentNode) {
                _context3.next = 8;
                break;
              }

              if (!(this.isEqual(key, currentNode.key) || key === null && !currentNode.right)) {
                _context3.next = 5;
                break;
              }

              return _context3.abrupt("break", 8);

            case 5:
              if (!this.isLessThan(key, currentNode.key) || key === null) {
                currentNode = currentNode.right;
              } else {
                currentNode = currentNode.left;
              }

              _context3.next = 2;
              break;

            case 8:
              if (currentNode) {
                _context3.next = 10;
                break;
              }

              return _context3.abrupt("return", null);

            case 10:
              fromright = true;

            case 11:
              if (!fromright) {
                _context3.next = 29;
                break;
              }

              _context3.next = 14;
              return [currentNode.key, currentNode.value];

            case 14:
              fromright = false;

              if (!currentNode.left) {
                _context3.next = 21;
                break;
              }

              currentNode = currentNode.left;

              while (currentNode.right) {
                currentNode = currentNode.right;
              }

              fromright = true;
              _context3.next = 27;
              break;

            case 21:
              if (!currentNode.parent) {
                _context3.next = 26;
                break;
              }

              fromright = currentNode.parent.right === currentNode;
              currentNode = currentNode.parent;
              _context3.next = 27;
              break;

            case 26:
              return _context3.abrupt("break", 37);

            case 27:
              _context3.next = 35;
              break;

            case 29:
              if (!currentNode.parent) {
                _context3.next = 34;
                break;
              }

              fromright = currentNode.parent.right === currentNode;
              currentNode = currentNode.parent;
              _context3.next = 35;
              break;

            case 34:
              return _context3.abrupt("break", 37);

            case 35:
              _context3.next = 11;
              break;

            case 37:
              return _context3.abrupt("return", null);

            case 38:
            case "end":
              return _context3.stop();
          }
        }
      }, getReverseIterator, this);
    })
  }]);

  return TreeMap;
}();

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var Entry = /*#__PURE__*/function () {
  function Entry(value, revision) {
    _classCallCheck__default['default'](this, Entry);

    this.value = value;
    this.revision = revision || 0;
  }

  _createClass__default['default'](Entry, [{
    key: "isValid",
    get: function get() {
      return true;
    }
  }]);

  return Entry;
}();

var Tombstone = /*#__PURE__*/function () {
  function Tombstone(revision) {
    _classCallCheck__default['default'](this, Tombstone);

    this.revision = revision;
  }

  _createClass__default['default'](Tombstone, [{
    key: "isValid",
    get: function get() {
      return false;
    }
  }]);

  return Tombstone;
}();

var Cache = /*#__PURE__*/function () {
  function Cache() {
    _classCallCheck__default['default'](this, Cache);

    this.items = new TreeMap();
  }

  _createClass__default['default'](Cache, [{
    key: "store",
    value: function store(key, value, revision) {
      var entry = this.items.get(key);

      if (entry && entry.revision > revision) {
        if (entry.isValid) {
          return entry.value;
        }

        return null;
      }

      this.items.set(key, new Entry(value, revision));
      return value;
    }
  }, {
    key: "delete",
    value: function _delete(key, revision) {
      var force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var curr = this.items.get(key);

      if (!curr || curr.revision < revision || curr && force === true
      /* forced delete when revision is unknown */
      ) {
          this.items.set(key, new Tombstone(revision));
        }
    }
  }, {
    key: "isKnown",
    value: function isKnown(key, revision) {
      var curr = this.items.get(key);
      return curr && curr.revision >= revision;
    }
  }, {
    key: "get",
    value: function get(key) {
      var entry = this.items.get(key);

      if (entry && entry.isValid) {
        return entry.value;
      }

      return null;
    }
  }, {
    key: "has",
    value: function has(key) {
      var entry = this.items.get(key);
      return entry && entry.isValid;
    }
  }, {
    key: "forEach",
    value: function forEach(callbackfn) {
      if (this.items) {
        var _iterator = _createForOfIteratorHelper(this.items),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var _step$value = _slicedToArray__default['default'](_step.value, 2),
                key = _step$value[0],
                entry = _step$value[1];

            if (entry.isValid) {
              callbackfn(key, entry.value);
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
    }
  }]);

  return Cache;
}();

function _createSuper$4(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$4(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

function _isNativeReflectConstruct$4() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var SyncListImpl = /*#__PURE__*/function (_SyncEntity) {
  _inherits__default['default'](SyncListImpl, _SyncEntity);

  var _super = _createSuper$4(SyncListImpl);

  /**
   * @private
   */
  function SyncListImpl(services, descriptor, removalHandler) {
    var _this;

    _classCallCheck__default['default'](this, SyncListImpl);

    _this = _super.call(this, services, removalHandler);

    var updateRequestReducer = function updateRequestReducer(acc, input) {
      return typeof input.ttl === 'number' ? {
        ttl: input.ttl
      } : acc;
    };

    _this.updateMergingQueue = new NamespacedMergingQueue(updateRequestReducer);
    _this.cache = new Cache();
    _this.descriptor = descriptor;
    _this.descriptor.date_updated = new Date(_this.descriptor.date_updated);
    return _this;
  } // private props


  _createClass__default['default'](SyncListImpl, [{
    key: "uri",
    get: function get() {
      return this.descriptor.url;
    }
  }, {
    key: "revision",
    get: function get() {
      return this.descriptor.revision;
    }
  }, {
    key: "lastEventId",
    get: function get() {
      return this.descriptor.last_event_id;
    }
  }, {
    key: "links",
    get: function get() {
      return this.descriptor.links;
    }
  }, {
    key: "dateExpires",
    get: function get() {
      return this.descriptor.date_expires;
    }
  }, {
    key: "type",
    get: function get() {
      return 'list';
    } // below properties are specific to Insights only

  }, {
    key: "indexName",
    get: function get() {
      return undefined;
    }
  }, {
    key: "queryString",
    get: function get() {
      return undefined;
    } // public props, documented along with class description

  }, {
    key: "sid",
    get: function get() {
      return this.descriptor.sid;
    }
  }, {
    key: "uniqueName",
    get: function get() {
      return this.descriptor.unique_name || null;
    }
  }, {
    key: "dateUpdated",
    get: function get() {
      return this.descriptor.date_updated;
    }
  }, {
    key: "_addOrUpdateItemOnServer",
    value: function () {
      var _addOrUpdateItemOnServer2 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee(url, data, ifMatch, ttl) {
        var requestBody, response;
        return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                requestBody = {
                  data: data
                };

                if (ttl !== undefined) {
                  requestBody.ttl = ttl;
                }

                _context.next = 4;
                return this.services.network.post(url, requestBody, ifMatch);

              case 4:
                response = _context.sent;
                response.body.data = data;
                response.body.date_updated = new Date(response.body.date_updated);
                return _context.abrupt("return", response.body);

              case 8:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function _addOrUpdateItemOnServer(_x, _x2, _x3, _x4) {
        return _addOrUpdateItemOnServer2.apply(this, arguments);
      }

      return _addOrUpdateItemOnServer;
    }()
  }, {
    key: "push",
    value: function () {
      var _push = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee2(value, itemMetadata) {
        var ttl, item, index;
        return _regeneratorRuntime__default['default'].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                ttl = (itemMetadata || {}).ttl;
                _context2.next = 3;
                return this._addOrUpdateItemOnServer(this.links.items, value, undefined, ttl);

              case 3:
                item = _context2.sent;
                index = Number(item.index);

                this._handleItemMutated(index, item.url, item.last_event_id, item.revision, value, item.date_updated, item.date_expires, true, false);

                return _context2.abrupt("return", this.cache.get(index));

              case 7:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function push(_x5, _x6) {
        return _push.apply(this, arguments);
      }

      return push;
    }()
  }, {
    key: "set",
    value: function () {
      var _set = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee3(index, value, itemMetadataUpdates) {
        var _this2 = this;

        var input;
        return _regeneratorRuntime__default['default'].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                input = itemMetadataUpdates || {};
                return _context3.abrupt("return", this.updateMergingQueue.squashAndAdd(index, input, function (input) {
                  return _this2._updateItemUnconditionally(index, value, input.ttl);
                }));

              case 2:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function set(_x7, _x8, _x9) {
        return _set.apply(this, arguments);
      }

      return set;
    }()
  }, {
    key: "_updateItemUnconditionally",
    value: function () {
      var _updateItemUnconditionally2 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee4(index, data, ttl) {
        var existingItem, itemDescriptor;
        return _regeneratorRuntime__default['default'].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.get(index);

              case 2:
                existingItem = _context4.sent;
                _context4.next = 5;
                return this._addOrUpdateItemOnServer(existingItem.uri, data, undefined, ttl);

              case 5:
                itemDescriptor = _context4.sent;

                this._handleItemMutated(index, itemDescriptor.url, itemDescriptor.last_event_id, itemDescriptor.revision, itemDescriptor.data, itemDescriptor.date_updated, itemDescriptor.date_expires, false, false);

                return _context4.abrupt("return", this.cache.get(index));

              case 8:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function _updateItemUnconditionally(_x10, _x11, _x12) {
        return _updateItemUnconditionally2.apply(this, arguments);
      }

      return _updateItemUnconditionally;
    }()
  }, {
    key: "_updateItemWithIfMatch",
    value: function () {
      var _updateItemWithIfMatch2 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee5(index, mutatorFunction, ttl) {
        var existingItem, data, ifMatch, itemDescriptor;
        return _regeneratorRuntime__default['default'].wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return this.get(index);

              case 2:
                existingItem = _context5.sent;
                data = mutatorFunction(deepClone(existingItem.data));

                if (!data) {
                  _context5.next = 25;
                  break;
                }

                ifMatch = existingItem.revision;
                _context5.prev = 6;
                _context5.next = 9;
                return this._addOrUpdateItemOnServer(existingItem.uri, data, ifMatch, ttl);

              case 9:
                itemDescriptor = _context5.sent;

                this._handleItemMutated(index, itemDescriptor.url, itemDescriptor.last_event_id, itemDescriptor.revision, itemDescriptor.data, itemDescriptor.date_updated, itemDescriptor.date_expires, false, false);

                return _context5.abrupt("return", this.cache.get(index));

              case 14:
                _context5.prev = 14;
                _context5.t0 = _context5["catch"](6);

                if (!(_context5.t0.status === 412)) {
                  _context5.next = 22;
                  break;
                }

                _context5.next = 19;
                return this._getItemFromServer(index);

              case 19:
                return _context5.abrupt("return", this._updateItemWithIfMatch(index, mutatorFunction, ttl));

              case 22:
                throw _context5.t0;

              case 23:
                _context5.next = 26;
                break;

              case 25:
                return _context5.abrupt("return", existingItem);

              case 26:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this, [[6, 14]]);
      }));

      function _updateItemWithIfMatch(_x13, _x14, _x15) {
        return _updateItemWithIfMatch2.apply(this, arguments);
      }

      return _updateItemWithIfMatch;
    }()
  }, {
    key: "mutate",
    value: function () {
      var _mutate = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee6(index, mutator, itemMetadataUpdates) {
        var _this3 = this;

        var input;
        return _regeneratorRuntime__default['default'].wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                input = itemMetadataUpdates || {};
                return _context6.abrupt("return", this.updateMergingQueue.add(index, input, function (input) {
                  return _this3._updateItemWithIfMatch(index, mutator, input.ttl);
                }));

              case 2:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function mutate(_x16, _x17, _x18) {
        return _mutate.apply(this, arguments);
      }

      return mutate;
    }()
  }, {
    key: "update",
    value: function () {
      var _update2 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee7(index, obj, itemMetadataUpdates) {
        return _regeneratorRuntime__default['default'].wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                return _context7.abrupt("return", this.mutate(index, function (remote) {
                  return Object.assign(remote, obj);
                }, itemMetadataUpdates));

              case 1:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function update(_x19, _x20, _x21) {
        return _update2.apply(this, arguments);
      }

      return update;
    }()
  }, {
    key: "remove",
    value: function () {
      var _remove = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee8(index) {
        var item, previousItemData, response;
        return _regeneratorRuntime__default['default'].wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return this.get(index);

              case 2:
                item = _context8.sent;
                previousItemData = deepClone(item.data);
                _context8.next = 6;
                return this.services.network.delete(item.uri);

              case 6:
                response = _context8.sent;

                this._handleItemRemoved(index, response.body.last_event_id, previousItemData, new Date(response.body.date_updated), false);

              case 8:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function remove(_x22) {
        return _remove.apply(this, arguments);
      }

      return remove;
    }()
  }, {
    key: "get",
    value: function () {
      var _get = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee9(index) {
        var cachedItem;
        return _regeneratorRuntime__default['default'].wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                cachedItem = this.cache.get(index);

                if (!cachedItem) {
                  _context9.next = 5;
                  break;
                }

                return _context9.abrupt("return", cachedItem);

              case 5:
                return _context9.abrupt("return", this._getItemFromServer(index));

              case 6:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function get(_x23) {
        return _get.apply(this, arguments);
      }

      return get;
    }()
  }, {
    key: "_getItemFromServer",
    value: function () {
      var _getItemFromServer2 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee10(index) {
        var result;
        return _regeneratorRuntime__default['default'].wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                _context10.next = 2;
                return this.queryItems({
                  index: index
                });

              case 2:
                result = _context10.sent;

                if (!(result.items.length < 1)) {
                  _context10.next = 7;
                  break;
                }

                throw new SyncError("No item with index ".concat(index, " found"), 404, 54151);

              case 7:
                return _context10.abrupt("return", result.items[0]);

              case 8:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function _getItemFromServer(_x24) {
        return _getItemFromServer2.apply(this, arguments);
      }

      return _getItemFromServer;
    }()
    /**
     * Query items from the List
     * @private
     */

  }, {
    key: "queryItems",
    value: function () {
      var _queryItems = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee11(arg) {
        var _this4 = this;

        var url, response, items, meta;
        return _regeneratorRuntime__default['default'].wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                arg = arg || {};
                url = new UriBuilder(this.links.items).queryParam('From', arg.from).queryParam('PageSize', arg.limit).queryParam('Index', arg.index).queryParam('PageToken', arg.pageToken).queryParam('Order', arg.order).build();
                _context11.next = 4;
                return this.services.network.get(url);

              case 4:
                response = _context11.sent;
                items = response.body.items.map(function (el) {
                  el.date_updated = new Date(el.date_updated);

                  var itemInCache = _this4.cache.get(el.index);

                  if (itemInCache) {
                    _this4._handleItemMutated(el.index, el.url, el.last_event_id, el.revision, el.data, el.date_updated, el.date_expires, false, true);
                  } else {
                    _this4.cache.store(Number(el.index), new SyncListItem({
                      index: Number(el.index),
                      uri: el.url,
                      revision: el.revision,
                      lastEventId: el.last_event_id,
                      dateUpdated: el.date_updated,
                      dateExpires: el.date_expires,
                      data: el.data
                    }), el.last_event_id);
                  }

                  return _this4.cache.get(el.index);
                });
                meta = response.body.meta;
                return _context11.abrupt("return", new Paginator(items, function (pageToken) {
                  return _this4.queryItems({
                    pageToken: pageToken
                  });
                }, meta.previous_token, meta.next_token));

              case 8:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function queryItems(_x25) {
        return _queryItems.apply(this, arguments);
      }

      return queryItems;
    }()
  }, {
    key: "getItems",
    value: function () {
      var _getItems = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee12(args) {
        return _regeneratorRuntime__default['default'].wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                args = args || {};
                validatePageSize(args.pageSize);
                args.limit = args.pageSize || args.limit || 50;
                args.order = args.order || 'asc';
                return _context12.abrupt("return", this.queryItems(args));

              case 5:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function getItems(_x26) {
        return _getItems.apply(this, arguments);
      }

      return getItems;
    }()
    /**
     * @return {Promise<Object>} Context of List
     * @private
     */

  }, {
    key: "getContext",
    value: function () {
      var _getContext = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee13() {
        var response;
        return _regeneratorRuntime__default['default'].wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                if (this.context) {
                  _context13.next = 5;
                  break;
                }

                _context13.next = 3;
                return this.services.network.get(this.links.context);

              case 3:
                response = _context13.sent;

                // store fetched context if we have't received any newer update
                this._updateContextIfRequired(response.body.data, response.body.last_event_id);

              case 5:
                return _context13.abrupt("return", this.context);

              case 6:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function getContext() {
        return _getContext.apply(this, arguments);
      }

      return getContext;
    }()
  }, {
    key: "setTtl",
    value: function () {
      var _setTtl = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee14(ttl) {
        var requestBody, response;
        return _regeneratorRuntime__default['default'].wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                _context14.prev = 0;
                requestBody = {
                  ttl: ttl
                };
                _context14.next = 4;
                return this.services.network.post(this.uri, requestBody);

              case 4:
                response = _context14.sent;
                this.descriptor.date_expires = response.body.date_expires;
                _context14.next = 12;
                break;

              case 8:
                _context14.prev = 8;
                _context14.t0 = _context14["catch"](0);

                if (_context14.t0.status === 404) {
                  this.onRemoved(false);
                }

                throw _context14.t0;

              case 12:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this, [[0, 8]]);
      }));

      function setTtl(_x27) {
        return _setTtl.apply(this, arguments);
      }

      return setTtl;
    }()
  }, {
    key: "setItemTtl",
    value: function () {
      var _setItemTtl = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee15(index, ttl) {
        var existingItem, requestBody, response;
        return _regeneratorRuntime__default['default'].wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                _context15.next = 2;
                return this.get(index);

              case 2:
                existingItem = _context15.sent;
                requestBody = {
                  ttl: ttl
                };
                _context15.next = 6;
                return this.services.network.post(existingItem.uri, requestBody);

              case 6:
                response = _context15.sent;
                existingItem.updateDateExpires(response.body.date_expires);

              case 8:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      function setItemTtl(_x28, _x29) {
        return _setItemTtl.apply(this, arguments);
      }

      return setItemTtl;
    }()
  }, {
    key: "removeList",
    value: function () {
      var _removeList = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee16() {
        return _regeneratorRuntime__default['default'].wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                _context16.next = 2;
                return this.services.network.delete(this.uri);

              case 2:
                this.onRemoved(true);

              case 3:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this);
      }));

      function removeList() {
        return _removeList.apply(this, arguments);
      }

      return removeList;
    }()
  }, {
    key: "onRemoved",
    value: function onRemoved(locally) {
      this._unsubscribe();

      this.removalHandler(this.type, this.sid, this.uniqueName);
      this.broadcastEventToListeners('removed', {
        isLocal: locally
      });
    }
  }, {
    key: "shouldIgnoreEvent",
    value: function shouldIgnoreEvent(key, eventId) {
      return this.cache.isKnown(key, eventId);
    }
    /**
     * Handle update, which came from the server.
     * @private
     */

  }, {
    key: "_update",
    value: function _update(update, isStrictlyOrdered) {
      var itemIndex = Number(update.item_index);
      update.date_created = new Date(update.date_created);

      switch (update.type) {
        case 'list_item_added':
        case 'list_item_updated':
          {
            this._handleItemMutated(itemIndex, update.item_url, update.id, update.item_revision, update.item_data, update.date_created, undefined, // orchestration does not include date_expires  -- @todo  it does now?
            update.type === 'list_item_added', true);
          }
          break;

        case 'list_item_removed':
          {
            this._handleItemRemoved(itemIndex, update.id, update.item_data, update.date_created, true);
          }
          break;

        case 'list_context_updated':
          {
            this._handleContextUpdate(update.context_data, update.id, update.date_created);
          }
          break;

        case 'list_removed':
          {
            this.onRemoved(false);
          }
          break;
      }

      if (isStrictlyOrdered) {
        this._advanceLastEventId(update.id, update.list_revision);
      }
    }
  }, {
    key: "_advanceLastEventId",
    value: function _advanceLastEventId(eventId, revision) {
      if (this.lastEventId < eventId) {
        this.descriptor.last_event_id = eventId;

        if (revision) {
          this.descriptor.revision = revision;
        }
      }
    }
  }, {
    key: "_updateRootDateUpdated",
    value: function _updateRootDateUpdated(dateUpdated) {
      if (!this.descriptor.date_updated || dateUpdated.getTime() > this.descriptor.date_updated.getTime()) {
        this.descriptor.date_updated = dateUpdated;
        this.services.storage.update(this.type, this.sid, this.uniqueName, {
          date_updated: dateUpdated
        });
      }
    }
  }, {
    key: "_handleItemMutated",
    value: function _handleItemMutated(index, uri, lastEventId, revision, data, dateUpdated, dateExpires, added, remote) {
      if (this.shouldIgnoreEvent(index, lastEventId)) {
        log$1.trace("Item ".concat(index, " update skipped, current: ").concat(this.lastEventId, ", remote: ").concat(lastEventId));
        return;
      }

      this._updateRootDateUpdated(dateUpdated);

      var item = this.cache.get(index);

      if (!item) {
        var newItem = new SyncListItem({
          index: index,
          uri: uri,
          lastEventId: lastEventId,
          revision: revision,
          data: data,
          dateUpdated: dateUpdated,
          dateExpires: dateExpires
        });
        this.cache.store(index, newItem, lastEventId);
        this.emitItemMutationEvent(newItem, remote, added);
        return;
      }

      var previousItemData = deepClone(item.data);
      item.update(lastEventId, revision, data, dateUpdated);
      this.cache.store(index, item, lastEventId);

      if (dateExpires !== undefined) {
        item.updateDateExpires(dateExpires);
      }

      this.emitItemMutationEvent(item, remote, false, previousItemData);
    }
    /**
     * @private
     */

  }, {
    key: "emitItemMutationEvent",
    value: function emitItemMutationEvent(item, remote, added) {
      var previousItemData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      var eventName = added ? 'itemAdded' : 'itemUpdated';
      var args = {
        item: item,
        isLocal: !remote
      };

      if (!added) {
        args.previousItemData = previousItemData;
      }

      this.broadcastEventToListeners(eventName, args);
    }
    /**
     * @private
     */

  }, {
    key: "_handleItemRemoved",
    value: function _handleItemRemoved(index, eventId, oldData, dateUpdated, remote) {
      this._updateRootDateUpdated(dateUpdated);

      this.cache.delete(index, eventId);
      this.broadcastEventToListeners('itemRemoved', {
        index: index,
        isLocal: !remote,
        previousItemData: oldData
      });
    }
    /**
     * @private
     */

  }, {
    key: "_handleContextUpdate",
    value: function _handleContextUpdate(data, eventId, dateUpdated) {
      this._updateRootDateUpdated(dateUpdated);

      if (this._updateContextIfRequired(data, eventId)) {
        this.broadcastEventToListeners('contextUpdated', {
          context: data,
          isLocal: false
        });
      }
    }
    /**
     * @private
     */

  }, {
    key: "_updateContextIfRequired",
    value: function _updateContextIfRequired(data, eventId) {
      if (!this.contextEventId || eventId > this.contextEventId) {
        this.context = data;
        this.contextEventId = eventId;
        return true;
      } else {
        log$1.trace('Context update skipped, current:', this.lastEventId, ', remote:', eventId);
        return false;
      }
    }
  }], [{
    key: "type",
    get: function get() {
      return 'list';
    }
  }]);

  return SyncListImpl;
}(SyncEntity);
/**
 * Represents a Sync list, which stores an ordered list of values.
 * Use the {@link SyncClient.list} method to obtain a reference to a Sync list.
 * Information about rate limits can be found [here](https://www.twilio.com/docs/sync/limits).
 */


var SyncList = /*#__PURE__*/function (_Closeable) {
  _inherits__default['default'](SyncList, _Closeable);

  var _super2 = _createSuper$4(SyncList);

  /**
   * @internal
   */
  function SyncList(syncListImpl) {
    var _this5;

    _classCallCheck__default['default'](this, SyncList);

    _this5 = _super2.call(this);
    _this5.syncListImpl = syncListImpl;

    _this5.syncListImpl.attach(_assertThisInitialized__default['default'](_this5));

    return _this5;
  }
  /**
   * Fired when a new item appears in the list, regardless of whether its creator was local or remote.
   *
   * Parameters:
   * 1. object `args` - info object provided with the event. It has the following properties:
   *     * {@link SyncListItem} `item` - added item
   *     * boolean `isLocal` - equals true if the item was added by a local actor, false otherwise
   * @example
   * ```typescript
   * list.on('itemAdded', (args) => {
   *   console.log(`List item ${args.item.index} was added`);
   *   console.log('args.item.data:', args.item.data);
   *   console.log('args.isLocal:', args.isLocal);
   * });
   * ```
   * @event
   */


  _createClass__default['default'](SyncList, [{
    key: "uri",
    get: // private props
    function get() {
      return this.syncListImpl.uri;
    }
  }, {
    key: "revision",
    get: function get() {
      return this.syncListImpl.revision;
    }
  }, {
    key: "lastEventId",
    get: function get() {
      return this.syncListImpl.lastEventId;
    }
  }, {
    key: "links",
    get: function get() {
      return this.syncListImpl.links;
    }
  }, {
    key: "dateExpires",
    get: function get() {
      return this.syncListImpl.dateExpires;
    }
  }, {
    key: "type",
    get: function get() {
      return SyncListImpl.type;
    }
    /**
     * Unique ID of the list, immutable identifier assigned by the system.
     */

  }, {
    key: "sid",
    get: function get() {
      return this.syncListImpl.sid;
    }
    /**
     * Unique name of the list, immutable identifier that can be assigned to the list during creation.
     */

  }, {
    key: "uniqueName",
    get: function get() {
      return this.syncListImpl.uniqueName;
    }
    /**
     * Date when the list was last updated, given in UTC ISO 8601 format (e.g., '2018-04-26T15:23:19.732Z').
     */

  }, {
    key: "dateUpdated",
    get: function get() {
      return this.syncListImpl.dateUpdated;
    }
  }, {
    key: "push",
    value:
    /**
     * Add a new item to the list.
     * @param data Data to be added.
     * @param itemMetadata Item metadata.
     * @return The newly added item.
     * @example
     * ```typescript
     * list.push({ name: 'John Smith' }, { ttl: 86400 })
     *   .then((item) => {
     *     console.log(`List Item push() successful, item index: ${item.index}, data:`, item.data)
     *   })
     *   .catch((error) => {
     *     console.error('List Item push() failed', error);
     *   });
     * ```
     */
    function () {
      var _push2 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee17(data, itemMetadata) {
        return _regeneratorRuntime__default['default'].wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                this.ensureNotClosed();
                return _context17.abrupt("return", this.syncListImpl.push(data, itemMetadata));

              case 2:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));

      function push(_x30, _x31) {
        return _push2.apply(this, arguments);
      }

      return push;
    }()
    /**
     * Assign new data to an existing item, given its index.
     * @param index Index of the item to be updated.
     * @param value New data to be assigned to an item.
     * @param itemMetadataUpdates New item metadata.
     * @return A promise with the updated item containing latest known data.
     * The promise will be rejected if the item does not exist.
     * @example
     * ```typescript
     * list.set(42, { name: 'John Smith' }, { ttl: 86400 })
     *   .then((item) => {
     *     console.log('List Item set() successful, item data:', item.data)
     *   })
     *   .catch((error) => {
     *     console.error('List Item set() failed', error);
     *   });
     * ```
     */

  }, {
    key: "set",
    value: function () {
      var _set2 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee18(index, value, itemMetadataUpdates) {
        return _regeneratorRuntime__default['default'].wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                this.ensureNotClosed();
                return _context18.abrupt("return", this.syncListImpl.set(index, value, itemMetadataUpdates));

              case 2:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this);
      }));

      function set(_x32, _x33, _x34) {
        return _set2.apply(this, arguments);
      }

      return set;
    }()
    /**
     * Modify an existing item by applying a mutation function to it.
     * @param index Index of the item to be changed.
     * @param mutator A function that outputs a new data based on the existing data.
     * @param itemMetadataUpdates New item metadata.
     * @return Resolves with the most recent item state, the output of a successful
     * mutation or a state that prompted graceful cancellation (mutator returned `null`). This promise
     * will be rejected if the indicated item does not already exist.
     * @example
     * ```typescript
     * const mutatorFunction = (currentValue) => {
     *     currentValue.viewCount = (currentValue.viewCount || 0) + 1;
     *     return currentValue;
     * };
     * list.mutate(42, mutatorFunction, { ttl: 86400 })
     *   .then((item) => {
     *     console.log('List Item mutate() successful, new data:', item.data)
     *   })
     *   .catch((error) => {
     *     console.error('List Item mutate() failed', error);
     *   });
     * ```
     */

  }, {
    key: "mutate",
    value: function () {
      var _mutate2 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee19(index, mutator, itemMetadataUpdates) {
        return _regeneratorRuntime__default['default'].wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                this.ensureNotClosed();
                return _context19.abrupt("return", this.syncListImpl.mutate(index, mutator, itemMetadataUpdates));

              case 2:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19, this);
      }));

      function mutate(_x35, _x36, _x37) {
        return _mutate2.apply(this, arguments);
      }

      return mutate;
    }()
    /**
     * Modify an existing item by appending new fields (or overwriting existing ones) with the values from the object.
     * This is equivalent to
     * ```typescript
     * list.mutate(42, (currentValue) => Object.assign(currentValue, obj));
     * ```
     * @param index Index of an item to be changed.
     * @param obj Set of fields to update.
     * @param itemMetadataUpdates New item metadata.
     * @return A promise with a modified item containing latest known data.
     * The promise will be rejected if the item was not found.
     * @example
     * ```typescript
     * // Say, the List Item (index: 42) data is `{ name: 'John Smith' }`
     * list.update(42, { age: 34 }, { ttl: 86400 })
     *   .then((item) => {
     *     // Now the List Item data is `{ name: 'John Smith', age: 34 }`
     *     console.log('List Item update() successful, new data:', item.data);
     *   })
     *   .catch((error) => {
     *     console.error('List Item update() failed', error);
     *   });
     * ```
     */

  }, {
    key: "update",
    value: function () {
      var _update3 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee20(index, obj, itemMetadataUpdates) {
        return _regeneratorRuntime__default['default'].wrap(function _callee20$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:
                this.ensureNotClosed();
                return _context20.abrupt("return", this.syncListImpl.update(index, obj, itemMetadataUpdates));

              case 2:
              case "end":
                return _context20.stop();
            }
          }
        }, _callee20, this);
      }));

      function update(_x38, _x39, _x40) {
        return _update3.apply(this, arguments);
      }

      return update;
    }()
    /**
     * Delete an item given its index.
     * @param index Index of the item to be removed.
     * @return A promise to remove the item.
     * The promise will be rejected if the item was not found.
     * @example
     * ```typescript
     * list.remove(42)
     *   .then(() => {
     *     console.log('List Item remove() successful');
     *   })
     *   .catch((error) => {
     *     console.error('List Item remove() failed', error);
     *   });
     * ```
     */

  }, {
    key: "remove",
    value: function () {
      var _remove2 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee21(index) {
        return _regeneratorRuntime__default['default'].wrap(function _callee21$(_context21) {
          while (1) {
            switch (_context21.prev = _context21.next) {
              case 0:
                this.ensureNotClosed();
                return _context21.abrupt("return", this.syncListImpl.remove(index));

              case 2:
              case "end":
                return _context21.stop();
            }
          }
        }, _callee21, this);
      }));

      function remove(_x41) {
        return _remove2.apply(this, arguments);
      }

      return remove;
    }()
    /**
     * Retrieve an item by List index.
     * @param index Item index in the list.
     * @return A promise with the item containing latest known data.
     * The promise will be rejected if the item was not found.
     * @example
     * ```typescript
     * list.get(42)
     *   .then((item) => {
     *     console.log('List Item get() successful, item data:', item.data)
     *   })
     *   .catch((error) => {
     *     console.error('List Item get() failed', error);
     *   });
     * ```
     */

  }, {
    key: "get",
    value: function () {
      var _get3 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee22(index) {
        return _regeneratorRuntime__default['default'].wrap(function _callee22$(_context22) {
          while (1) {
            switch (_context22.prev = _context22.next) {
              case 0:
                this.ensureNotClosed();
                return _context22.abrupt("return", this.syncListImpl.get(index));

              case 2:
              case "end":
                return _context22.stop();
            }
          }
        }, _callee22, this);
      }));

      function get(_x42) {
        return _get3.apply(this, arguments);
      }

      return get;
    }()
    /**
     * Retrieve a list context
     * @return A promise with the list's context
     * @internal
     */

  }, {
    key: "getContext",
    value: function () {
      var _getContext2 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee23() {
        return _regeneratorRuntime__default['default'].wrap(function _callee23$(_context23) {
          while (1) {
            switch (_context23.prev = _context23.next) {
              case 0:
                this.ensureNotClosed();
                return _context23.abrupt("return", this.syncListImpl.getContext());

              case 2:
              case "end":
                return _context23.stop();
            }
          }
        }, _callee23, this);
      }));

      function getContext() {
        return _getContext2.apply(this, arguments);
      }

      return getContext;
    }()
    /**
     * Query a list of items from collection.
     * Information about the query limits can be found {@link https://www.twilio.com/docs/sync/limits|here}.
     * @param queryOptions Query options.
     * @example
     * ```typescript
     * const pageHandler = (paginator) => {
     *   paginator.items.forEach((item) => {
     *     console.log(`Item ${item.index}:`, item.data);
     *   });
     *   return paginator.hasNextPage
     *     ? paginator.nextPage().then(pageHandler)
     *     : null;
     * };
     * list.getItems({ from: 0, order: 'asc' })
     *   .then(pageHandler)
     *   .catch((error) => {
     *     console.error('List getItems() failed', error);
     *   });
     * ```
     */

  }, {
    key: "getItems",
    value: function () {
      var _getItems2 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee24(queryOptions) {
        return _regeneratorRuntime__default['default'].wrap(function _callee24$(_context24) {
          while (1) {
            switch (_context24.prev = _context24.next) {
              case 0:
                this.ensureNotClosed();
                return _context24.abrupt("return", this.syncListImpl.getItems(queryOptions));

              case 2:
              case "end":
                return _context24.stop();
            }
          }
        }, _callee24, this);
      }));

      function getItems(_x43) {
        return _getItems2.apply(this, arguments);
      }

      return getItems;
    }()
    /**
     * Update the time-to-live of the list.
     * @param ttl Specifies the TTL in seconds after which the list is subject to automatic deletion. The value 0 means infinity.
     * @return A promise that resolves after the TTL update was successful.
     * @example
     * ```typescript
     * list.setTtl(3600)
     *   .then(() => {
     *     console.log('List setTtl() successful');
     *   })
     *   .catch((error) => {
     *     console.error('List setTtl() failed', error);
     *   });
     * ```
     */

  }, {
    key: "setTtl",
    value: function () {
      var _setTtl2 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee25(ttl) {
        return _regeneratorRuntime__default['default'].wrap(function _callee25$(_context25) {
          while (1) {
            switch (_context25.prev = _context25.next) {
              case 0:
                this.ensureNotClosed();
                return _context25.abrupt("return", this.syncListImpl.setTtl(ttl));

              case 2:
              case "end":
                return _context25.stop();
            }
          }
        }, _callee25, this);
      }));

      function setTtl(_x44) {
        return _setTtl2.apply(this, arguments);
      }

      return setTtl;
    }()
    /**
     * Update the time-to-live of a list item.
     * @param index Item index.
     * @param ttl Specifies the TTL in seconds after which the list item is subject to automatic deletion. The value 0 means infinity.
     * @return A promise that resolves after the TTL update was successful.
     * @example
     * ```typescript
     * list.setItemTtl(42, 86400)
     *   .then(() => {
     *     console.log('List setItemTtl() successful');
     *   })
     *   .catch((error) => {
     *     console.error('List setItemTtl() failed', error);
     *   });
     * ```
     */

  }, {
    key: "setItemTtl",
    value: function () {
      var _setItemTtl2 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee26(index, ttl) {
        return _regeneratorRuntime__default['default'].wrap(function _callee26$(_context26) {
          while (1) {
            switch (_context26.prev = _context26.next) {
              case 0:
                this.ensureNotClosed();
                return _context26.abrupt("return", this.syncListImpl.setItemTtl(index, ttl));

              case 2:
              case "end":
                return _context26.stop();
            }
          }
        }, _callee26, this);
      }));

      function setItemTtl(_x45, _x46) {
        return _setItemTtl2.apply(this, arguments);
      }

      return setItemTtl;
    }()
    /**
     * Delete this list. It will be impossible to restore it.
     * @return A promise that resolves when the list has been deleted.
     * @example
     * list.removeList()
     *   .then(() => {
     *     console.log('List removeList() successful');
     *   })
     *   .catch((error) => {
     *     console.error('List removeList() failed', error);
     *   });
     */

  }, {
    key: "removeList",
    value: function () {
      var _removeList2 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee27() {
        return _regeneratorRuntime__default['default'].wrap(function _callee27$(_context27) {
          while (1) {
            switch (_context27.prev = _context27.next) {
              case 0:
                this.ensureNotClosed();
                return _context27.abrupt("return", this.syncListImpl.removeList());

              case 2:
              case "end":
                return _context27.stop();
            }
          }
        }, _callee27, this);
      }));

      function removeList() {
        return _removeList2.apply(this, arguments);
      }

      return removeList;
    }()
    /**
     * Conclude work with the list instance and remove all event listeners attached to it.
     * Any subsequent operation on this object will be rejected with error.
     * Other local copies of this list will continue operating and receiving events normally.
     * @example
     * ```typescript
     * list.close();
     * ```
     */

  }, {
    key: "close",
    value: function close() {
      _get__default['default'](_getPrototypeOf__default['default'](SyncList.prototype), "close", this).call(this);

      this.syncListImpl.detach(this.listenerUuid);
    }
  }], [{
    key: "type",
    get: function get() {
      return SyncListImpl.type;
    }
  }]);

  return SyncList;
}(Closeable);

_defineProperty__default['default'](SyncList, "itemAdded", 'itemAdded');

_defineProperty__default['default'](SyncList, "itemUpdated", 'itemUpdated');

_defineProperty__default['default'](SyncList, "itemRemoved", 'itemRemoved');

_defineProperty__default['default'](SyncList, "removed", 'removed');

__decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.pureObject, ['undefined', declarativeTypeValidator.objectSchema('item metadata', {
  ttl: [declarativeTypeValidator.nonNegativeInteger, 'undefined']
})]), __metadata("design:type", Function), __metadata("design:paramtypes", [Object, Object]), __metadata("design:returntype", Promise)], SyncList.prototype, "push", null);

__decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonNegativeInteger, declarativeTypeValidator.pureObject, ['undefined', declarativeTypeValidator.objectSchema('item metadata', {
  ttl: [declarativeTypeValidator.nonNegativeInteger, 'undefined']
})]), __metadata("design:type", Function), __metadata("design:paramtypes", [Number, Object, Object]), __metadata("design:returntype", Promise)], SyncList.prototype, "set", null);

__decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonNegativeInteger, 'function', ['undefined', declarativeTypeValidator.objectSchema('item metadata', {
  ttl: [declarativeTypeValidator.nonNegativeInteger, 'undefined']
})]), __metadata("design:type", Function), __metadata("design:paramtypes", [Number, Function, Object]), __metadata("design:returntype", Promise)], SyncList.prototype, "mutate", null);

__decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonNegativeInteger, declarativeTypeValidator.pureObject, ['undefined', declarativeTypeValidator.objectSchema('item metadata', {
  ttl: [declarativeTypeValidator.nonNegativeInteger, 'undefined']
})]), __metadata("design:type", Function), __metadata("design:paramtypes", [Number, Object, Object]), __metadata("design:returntype", Promise)], SyncList.prototype, "update", null);

__decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonNegativeInteger), __metadata("design:type", Function), __metadata("design:paramtypes", [Number]), __metadata("design:returntype", Promise)], SyncList.prototype, "remove", null);

__decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonNegativeInteger), __metadata("design:type", Function), __metadata("design:paramtypes", [Number]), __metadata("design:returntype", Promise)], SyncList.prototype, "get", null);

__decorate([declarativeTypeValidator.validateTypesAsync(['undefined', declarativeTypeValidator.objectSchema('query options', {
  from: [declarativeTypeValidator.nonNegativeInteger, 'undefined'],
  pageSize: [declarativeTypeValidator.custom(function (value) {
    return [isPositiveInteger(value), 'a positive integer'];
  }), 'undefined']
})]), __metadata("design:type", Function), __metadata("design:paramtypes", [Object]), __metadata("design:returntype", Promise)], SyncList.prototype, "getItems", null);

__decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonNegativeInteger), __metadata("design:type", Function), __metadata("design:paramtypes", [Number]), __metadata("design:returntype", Promise)], SyncList.prototype, "setTtl", null);

__decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonNegativeInteger, declarativeTypeValidator.nonNegativeInteger), __metadata("design:type", Function), __metadata("design:paramtypes", [Number, Number]), __metadata("design:returntype", Promise)], SyncList.prototype, "setItemTtl", null);

/**
 * Represents an individual element in a Sync map.
 */
var SyncMapItem = /*#__PURE__*/function () {
  /**
   * @internal
   */
  function SyncMapItem(descriptor) {
    _classCallCheck__default['default'](this, SyncMapItem);

    this.descriptor = descriptor;
  }

  _createClass__default['default'](SyncMapItem, [{
    key: "uri",
    get: function get() {
      return this.descriptor.url;
    }
  }, {
    key: "revision",
    get: function get() {
      return this.descriptor.revision;
    }
  }, {
    key: "lastEventId",
    get: function get() {
      return this.descriptor.last_event_id;
    }
  }, {
    key: "dateExpires",
    get: function get() {
      return this.descriptor.date_expires;
    }
    /**
     * The identifier that maps to this item within the containing Map.
     */

  }, {
    key: "key",
    get: function get() {
      return this.descriptor.key;
    }
    /**
     * The contents of the item.
     */

  }, {
    key: "data",
    get: function get() {
      return this.descriptor.data;
    }
    /**
     * Date when the map item was last updated.
     */

  }, {
    key: "dateUpdated",
    get: function get() {
      return this.descriptor.date_updated;
    }
    /**
     * @internal
     */

  }, {
    key: "update",
    value: function update(eventId, revision, value, dateUpdated) {
      this.descriptor.last_event_id = eventId;
      this.descriptor.revision = revision;
      this.descriptor.data = value;
      this.descriptor.date_updated = dateUpdated;
      return this;
    }
    /**
     * @internal
     */

  }, {
    key: "updateDateExpires",
    value: function updateDateExpires(dateExpires) {
      this.descriptor.date_expires = dateExpires;
    }
  }]);

  return SyncMapItem;
}();

function _createSuper$3(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$3(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

function _isNativeReflectConstruct$3() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var SyncMapImpl = /*#__PURE__*/function (_SyncEntity) {
  _inherits__default['default'](SyncMapImpl, _SyncEntity);

  var _super = _createSuper$3(SyncMapImpl);

  /**
   * @private
   */
  function SyncMapImpl(services, descriptor, removalHandler) {
    var _this;

    _classCallCheck__default['default'](this, SyncMapImpl);

    _this = _super.call(this, services, removalHandler);

    var updateRequestReducer = function updateRequestReducer(acc, input) {
      return typeof input.ttl === 'number' ? {
        ttl: input.ttl
      } : acc;
    };

    _this.updateMergingQueue = new NamespacedMergingQueue(updateRequestReducer);
    _this.cache = new Cache();
    _this.descriptor = descriptor;
    _this.descriptor.date_updated = new Date(_this.descriptor.date_updated);

    if (descriptor.items) {
      descriptor.items.forEach(function (itemDescriptor) {
        itemDescriptor.date_updated = new Date(itemDescriptor.date_updated);

        _this.cache.store(itemDescriptor.key, new SyncMapItem(itemDescriptor), itemDescriptor.last_event_id);
      });
    }

    return _this;
  } // private props


  _createClass__default['default'](SyncMapImpl, [{
    key: "uri",
    get: function get() {
      return this.descriptor.url;
    }
  }, {
    key: "links",
    get: function get() {
      return this.descriptor.links;
    }
  }, {
    key: "revision",
    get: function get() {
      return this.descriptor.revision;
    }
  }, {
    key: "lastEventId",
    get: function get() {
      return this.descriptor.last_event_id;
    }
  }, {
    key: "dateExpires",
    get: function get() {
      return this.descriptor.date_expires;
    }
  }, {
    key: "type",
    get: function get() {
      return 'map';
    } // below properties are specific to Insights only

  }, {
    key: "indexName",
    get: function get() {
      return undefined;
    }
  }, {
    key: "queryString",
    get: function get() {
      return undefined;
    } // public props, documented along with class description

  }, {
    key: "sid",
    get: function get() {
      return this.descriptor.sid;
    }
  }, {
    key: "uniqueName",
    get: function get() {
      return this.descriptor.unique_name || null;
    }
  }, {
    key: "dateUpdated",
    get: function get() {
      return this.descriptor.date_updated;
    }
  }, {
    key: "set",
    value: function () {
      var _set = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee(key, value, itemMetadataUpdates) {
        var _this2 = this;

        var input;
        return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                input = itemMetadataUpdates || {};
                return _context.abrupt("return", this.updateMergingQueue.squashAndAdd(key, input, function (input) {
                  return _this2._putItemUnconditionally(key, value, input.ttl);
                }));

              case 2:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function set(_x, _x2, _x3) {
        return _set.apply(this, arguments);
      }

      return set;
    }()
  }, {
    key: "get",
    value: function () {
      var _get = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee2(key) {
        return _regeneratorRuntime__default['default'].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!(key === null || key === undefined)) {
                  _context2.next = 2;
                  break;
                }

                throw new SyncError('SyncMapItem key may not be empty', 400, 54209);

              case 2:
                if (!this.cache.has(key)) {
                  _context2.next = 6;
                  break;
                }

                return _context2.abrupt("return", this.cache.get(key));

              case 6:
                return _context2.abrupt("return", this._getItemFromServer(key));

              case 7:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function get(_x4) {
        return _get.apply(this, arguments);
      }

      return get;
    }()
  }, {
    key: "_getItemFromServer",
    value: function () {
      var _getItemFromServer2 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee3(key) {
        var result;
        return _regeneratorRuntime__default['default'].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.queryItems({
                  key: key
                });

              case 2:
                result = _context3.sent;

                if (!(result.items.length < 1)) {
                  _context3.next = 7;
                  break;
                }

                throw new SyncError("The specified Map Item does not exist", 404, 54201);

              case 7:
                return _context3.abrupt("return", result.items[0]);

              case 8:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function _getItemFromServer(_x5) {
        return _getItemFromServer2.apply(this, arguments);
      }

      return _getItemFromServer;
    }()
  }, {
    key: "mutate",
    value: function () {
      var _mutate = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee4(key, mutator, itemMetadataUpdates) {
        var _this3 = this;

        var input;
        return _regeneratorRuntime__default['default'].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                input = itemMetadataUpdates || {};
                return _context4.abrupt("return", this.updateMergingQueue.add(key, input, function (input) {
                  return _this3._putItemWithIfMatch(key, mutator, input.ttl);
                }));

              case 2:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function mutate(_x6, _x7, _x8) {
        return _mutate.apply(this, arguments);
      }

      return mutate;
    }()
  }, {
    key: "update",
    value: function () {
      var _update2 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee5(key, obj, itemMetadataUpdates) {
        return _regeneratorRuntime__default['default'].wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                return _context5.abrupt("return", this.mutate(key, function (remote) {
                  return Object.assign(remote, obj);
                }, itemMetadataUpdates));

              case 1:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function update(_x9, _x10, _x11) {
        return _update2.apply(this, arguments);
      }

      return update;
    }()
  }, {
    key: "_putItemUnconditionally",
    value: function () {
      var _putItemUnconditionally2 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee6(key, data, ttl) {
        var result, item;
        return _regeneratorRuntime__default['default'].wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return this._putItemToServer(key, data, undefined, ttl);

              case 2:
                result = _context6.sent;
                item = result.item;

                this._handleItemMutated(item.key, item.url, item.last_event_id, item.revision, item.data, item.date_updated, item.date_expires, result.added, false);

                return _context6.abrupt("return", this.cache.get(item.key));

              case 6:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function _putItemUnconditionally(_x12, _x13, _x14) {
        return _putItemUnconditionally2.apply(this, arguments);
      }

      return _putItemUnconditionally;
    }()
  }, {
    key: "_putItemWithIfMatch",
    value: function () {
      var _putItemWithIfMatch2 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee7(key, mutatorFunction, ttl) {
        var currentItem, data, ifMatch, result, item;
        return _regeneratorRuntime__default['default'].wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return this.get(key).catch(function (error) {
                  if (error.status === 404) {
                    // PUT /Items/myKey with `If-Match: -1` acts as "put if not exists"
                    return new SyncMapItem({
                      key: key,
                      data: {},
                      last_event_id: -1,
                      revision: '-1',
                      url: null,
                      date_updated: null,
                      date_expires: null
                    });
                  } else {
                    throw error;
                  }
                });

              case 2:
                currentItem = _context7.sent;
                data = mutatorFunction(deepClone(currentItem.data));

                if (!data) {
                  _context7.next = 26;
                  break;
                }

                ifMatch = currentItem.revision;
                _context7.prev = 6;
                _context7.next = 9;
                return this._putItemToServer(key, data, ifMatch, ttl);

              case 9:
                result = _context7.sent;
                item = result.item;

                this._handleItemMutated(item.key, item.url, item.last_event_id, item.revision, item.data, item.date_updated, item.date_expires, result.added, false);

                return _context7.abrupt("return", this.cache.get(item.key));

              case 15:
                _context7.prev = 15;
                _context7.t0 = _context7["catch"](6);

                if (!(_context7.t0.status === 412)) {
                  _context7.next = 23;
                  break;
                }

                _context7.next = 20;
                return this._getItemFromServer(key);

              case 20:
                return _context7.abrupt("return", this._putItemWithIfMatch(key, mutatorFunction, ttl));

              case 23:
                throw _context7.t0;

              case 24:
                _context7.next = 27;
                break;

              case 26:
                return _context7.abrupt("return", currentItem);

              case 27:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this, [[6, 15]]);
      }));

      function _putItemWithIfMatch(_x15, _x16, _x17) {
        return _putItemWithIfMatch2.apply(this, arguments);
      }

      return _putItemWithIfMatch;
    }()
  }, {
    key: "_putItemToServer",
    value: function () {
      var _putItemToServer2 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee8(key, data, ifMatch, ttl) {
        var url, requestBody, response, mapItemDescriptor, added;
        return _regeneratorRuntime__default['default'].wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                url = new UriBuilder(this.links.items).pathSegment(key).build();
                requestBody = {
                  data: data
                };

                if (ttl !== undefined) {
                  requestBody.ttl = ttl;
                }

                _context8.prev = 3;
                _context8.next = 6;
                return this.services.network.put(url, requestBody, ifMatch);

              case 6:
                response = _context8.sent;
                mapItemDescriptor = response.body;
                mapItemDescriptor.data = data; // The server does not return the data in the response

                mapItemDescriptor.date_updated = new Date(mapItemDescriptor.date_updated);
                added = response.status.code === 201;
                return _context8.abrupt("return", {
                  added: added,
                  item: mapItemDescriptor
                });

              case 14:
                _context8.prev = 14;
                _context8.t0 = _context8["catch"](3);

                if (_context8.t0.status === 404) {
                  this.onRemoved(false);
                }

                throw _context8.t0;

              case 18:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this, [[3, 14]]);
      }));

      function _putItemToServer(_x18, _x19, _x20, _x21) {
        return _putItemToServer2.apply(this, arguments);
      }

      return _putItemToServer;
    }()
  }, {
    key: "remove",
    value: function () {
      var _remove = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee9(key) {
        var item, previousItemData, response;
        return _regeneratorRuntime__default['default'].wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return this.get(key);

              case 2:
                item = _context9.sent;
                previousItemData = deepClone(item.data);
                _context9.next = 6;
                return this.services.network.delete(item.uri);

              case 6:
                response = _context9.sent;

                this._handleItemRemoved(key, response.body.last_event_id, previousItemData, new Date(response.body.date_updated), false);

              case 8:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function remove(_x22) {
        return _remove.apply(this, arguments);
      }

      return remove;
    }()
    /**
     * @private
     */

  }, {
    key: "queryItems",
    value: function () {
      var _queryItems = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee10(args) {
        var _this4 = this;

        var uri, response, items, meta;
        return _regeneratorRuntime__default['default'].wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                args = args || {};
                uri = new UriBuilder(this.links.items).queryParam('From', args.from).queryParam('PageSize', args.limit).queryParam('Key', args.key).queryParam('PageToken', args.pageToken).queryParam('Order', args.order).build();
                _context10.next = 4;
                return this.services.network.get(uri);

              case 4:
                response = _context10.sent;
                items = response.body.items.map(function (el) {
                  el.date_updated = new Date(el.date_updated);

                  var itemInCache = _this4.cache.get(el.key);

                  if (itemInCache) {
                    _this4._handleItemMutated(el.key, el.url, el.last_event_id, el.revision, el.data, el.date_updated, el.date_expires, false, true);
                  } else {
                    _this4.cache.store(el.key, new SyncMapItem(el), el.last_event_id);
                  }

                  return _this4.cache.get(el.key);
                });
                meta = response.body.meta;
                return _context10.abrupt("return", new Paginator(items, function (pageToken) {
                  return _this4.queryItems({
                    pageToken: pageToken
                  });
                }, meta.previous_token, meta.next_token));

              case 8:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function queryItems(_x23) {
        return _queryItems.apply(this, arguments);
      }

      return queryItems;
    }()
  }, {
    key: "getItems",
    value: function () {
      var _getItems = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee11(args) {
        return _regeneratorRuntime__default['default'].wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                args = args || {};
                validatePageSize(args.pageSize);
                args.limit = args.pageSize || args.limit || 50;
                args.order = args.order || 'asc';
                return _context11.abrupt("return", this.queryItems(args));

              case 5:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function getItems(_x24) {
        return _getItems.apply(this, arguments);
      }

      return getItems;
    }()
  }, {
    key: "shouldIgnoreEvent",
    value: function shouldIgnoreEvent(key, eventId) {
      return this.cache.isKnown(key, eventId);
    }
    /**
     * Handle update from the server
     * @private
     */

  }, {
    key: "_update",
    value: function _update(update, isStrictlyOrdered) {
      update.date_created = new Date(update.date_created);

      switch (update.type) {
        case 'map_item_added':
        case 'map_item_updated':
          {
            this._handleItemMutated(update.item_key, update.item_url, update.id, update.item_revision, update.item_data, update.date_created, undefined, // orchestration events do not include date_expires
            update.type === 'map_item_added', true);
          }
          break;

        case 'map_item_removed':
          {
            this._handleItemRemoved(update.item_key, update.id, update.item_data, update.date_created, true);
          }
          break;

        case 'map_removed':
          {
            this.onRemoved(false);
          }
          break;
      }

      if (isStrictlyOrdered) {
        this._advanceLastEventId(update.id, update.map_revision);
      }
    }
  }, {
    key: "_advanceLastEventId",
    value: function _advanceLastEventId(eventId, revision) {
      if (this.lastEventId < eventId) {
        this.descriptor.last_event_id = eventId;

        if (revision) {
          this.descriptor.revision = revision;
        }
      }
    }
  }, {
    key: "_updateRootDateUpdated",
    value: function _updateRootDateUpdated(dateUpdated) {
      if (!this.descriptor.date_updated || dateUpdated.getTime() > this.descriptor.date_updated.getTime()) {
        this.descriptor.date_updated = dateUpdated;
        this.services.storage.update(this.type, this.sid, this.uniqueName, {
          date_updated: dateUpdated
        });
      }
    }
  }, {
    key: "_handleItemMutated",
    value: function _handleItemMutated(key, url, lastEventId, revision, data, dateUpdated, dateExpires, added, remote) {
      if (this.shouldIgnoreEvent(key, lastEventId)) {
        log$1.trace('SyncMapItem ', key, ' update skipped, current:', this.lastEventId, ', remote:', lastEventId);
        return;
      }

      this._updateRootDateUpdated(dateUpdated);

      var item = this.cache.get(key);

      if (!item) {
        var newItem = new SyncMapItem({
          key: key,
          url: url,
          last_event_id: lastEventId,
          revision: revision,
          data: data,
          date_updated: dateUpdated,
          date_expires: dateExpires
        });
        this.cache.store(key, newItem, lastEventId);
        this.emitItemMutationEvent(newItem, remote, added);
        return;
      }

      var previousItemData = deepClone(item.data);
      item.update(lastEventId, revision, data, dateUpdated);
      this.cache.store(key, item, lastEventId);

      if (dateExpires !== undefined) {
        item.updateDateExpires(dateExpires);
      }

      this.emitItemMutationEvent(item, remote, false, previousItemData);
    }
  }, {
    key: "emitItemMutationEvent",
    value: function emitItemMutationEvent(item, remote, added) {
      var previousItemData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      var eventName = added ? 'itemAdded' : 'itemUpdated';
      var args = {
        item: item,
        isLocal: !remote
      };

      if (!added) {
        args.previousItemData = previousItemData;
      }

      this.broadcastEventToListeners(eventName, args);
    }
    /**
     * @private
     */

  }, {
    key: "_handleItemRemoved",
    value: function _handleItemRemoved(key, eventId, oldData, dateUpdated, remote) {
      this._updateRootDateUpdated(dateUpdated);

      this.cache.delete(key, eventId);
      this.broadcastEventToListeners('itemRemoved', {
        key: key,
        isLocal: !remote,
        previousItemData: oldData
      });
    }
  }, {
    key: "onRemoved",
    value: function onRemoved(locally) {
      this._unsubscribe();

      this.removalHandler(this.type, this.sid, this.uniqueName);
      this.broadcastEventToListeners('removed', {
        isLocal: locally
      });
    }
  }, {
    key: "setTtl",
    value: function () {
      var _setTtl = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee12(ttl) {
        var requestBody, response;
        return _regeneratorRuntime__default['default'].wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                _context12.prev = 0;
                requestBody = {
                  ttl: ttl
                };
                _context12.next = 4;
                return this.services.network.post(this.uri, requestBody);

              case 4:
                response = _context12.sent;
                this.descriptor.date_expires = response.body.date_expires;
                _context12.next = 12;
                break;

              case 8:
                _context12.prev = 8;
                _context12.t0 = _context12["catch"](0);

                if (_context12.t0.status === 404) {
                  this.onRemoved(false);
                }

                throw _context12.t0;

              case 12:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this, [[0, 8]]);
      }));

      function setTtl(_x25) {
        return _setTtl.apply(this, arguments);
      }

      return setTtl;
    }()
  }, {
    key: "setItemTtl",
    value: function () {
      var _setItemTtl = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee13(key, ttl) {
        var existingItem, requestBody, response;
        return _regeneratorRuntime__default['default'].wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                _context13.next = 2;
                return this.get(key);

              case 2:
                existingItem = _context13.sent;
                requestBody = {
                  ttl: ttl
                };
                _context13.next = 6;
                return this.services.network.post(existingItem.uri, requestBody);

              case 6:
                response = _context13.sent;
                existingItem.updateDateExpires(response.body.date_expires);

              case 8:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function setItemTtl(_x26, _x27) {
        return _setItemTtl.apply(this, arguments);
      }

      return setItemTtl;
    }()
  }, {
    key: "removeMap",
    value: function () {
      var _removeMap = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee14() {
        return _regeneratorRuntime__default['default'].wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                _context14.next = 2;
                return this.services.network.delete(this.uri);

              case 2:
                this.onRemoved(true);

              case 3:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function removeMap() {
        return _removeMap.apply(this, arguments);
      }

      return removeMap;
    }()
  }], [{
    key: "type",
    get: function get() {
      return 'map';
    }
  }]);

  return SyncMapImpl;
}(SyncEntity);
/**
 * Represents a Sync map, which is a data structure that stores an unordered set of key-value pairs.
 * Use the {@link SyncClient.map} method to obtain a reference to a Sync map.
 * Information about rate limits can be found [here](https://www.twilio.com/docs/sync/limits).
 */


var SyncMap = /*#__PURE__*/function (_Closeable) {
  _inherits__default['default'](SyncMap, _Closeable);

  var _super2 = _createSuper$3(SyncMap);

  /**
   * @internal
   */
  function SyncMap(syncMapImpl) {
    var _this5;

    _classCallCheck__default['default'](this, SyncMap);

    _this5 = _super2.call(this);
    _this5.syncMapImpl = syncMapImpl;

    _this5.syncMapImpl.attach(_assertThisInitialized__default['default'](_this5));

    return _this5;
  }
  /**
   * Fired when a new item appears in the map, regardless of whether its creator was local or remote.
   *
   * Parameters:
   * 1. object `args` - info object provided with the event. It has the following properties:
   *     * {@link SyncMapItem} `item` - added item
   *     * boolean `isLocal` - equals true if the item was added by a local actor, false otherwise
   * @example
   * ```typescript
   * map.on('itemAdded', (args) => {
   *   console.log(`Map item ${args.item.key} was added`);
   *   console.log('args.item.data:', args.item.data);
   *   console.log('args.isLocal:', args.isLocal);
   * });
   * ```
   * @event
   */


  _createClass__default['default'](SyncMap, [{
    key: "uri",
    get: // private props
    function get() {
      return this.syncMapImpl.uri;
    }
  }, {
    key: "links",
    get: function get() {
      return this.syncMapImpl.links;
    }
  }, {
    key: "revision",
    get: function get() {
      return this.syncMapImpl.revision;
    }
  }, {
    key: "lastEventId",
    get: function get() {
      return this.syncMapImpl.lastEventId;
    }
  }, {
    key: "dateExpires",
    get: function get() {
      return this.syncMapImpl.dateExpires;
    }
  }, {
    key: "type",
    get: function get() {
      return SyncMapImpl.type;
    }
    /**
     * An immutable identifier (a SID) assigned by the system on creation.
     */

  }, {
    key: "sid",
    get: function get() {
      return this.syncMapImpl.sid;
    }
    /**
     * An optional immutable identifier that may be assigned by the
     * programmer to this map on creation. Unique among other Maps.
     */

  }, {
    key: "uniqueName",
    get: function get() {
      return this.syncMapImpl.uniqueName;
    }
    /**
     * Date when the map was last updated.
     */

  }, {
    key: "dateUpdated",
    get: function get() {
      return this.syncMapImpl.dateUpdated;
    }
  }, {
    key: "set",
    value:
    /**
     * Add a new item to the map with the given key-value pair. Overwrites any data that might already exist with that key.
     * @param key Unique item identifier.
     * @param data Data to be set.
     * @param itemMetadataUpdates New item metadata.
     * @return Newly added item, or modified one if already exists, with the latest known data.
     * @example
     * ```typescript
     * map.set('myKey', { name: 'John Smith' }, { ttl: 86400 })
     *   .then((item) => {
     *     console.log('Map SyncMapItem set() successful, item data:', item.data);
     *   })
     *   .catch((error) => {
     *     console.error('Map SyncMapItem set() failed', error);
     *   });
     * ```
     */
    function () {
      var _set2 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee15(key, data, itemMetadataUpdates) {
        return _regeneratorRuntime__default['default'].wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                this.ensureNotClosed();
                return _context15.abrupt("return", this.syncMapImpl.set(key, data, itemMetadataUpdates));

              case 2:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      function set(_x28, _x29, _x30) {
        return _set2.apply(this, arguments);
      }

      return set;
    }()
    /**
     * Retrieve an item by key.
     * @param key Identifies the desired item.
     * @return A promise that resolves when the item has been fetched.
     * This promise will be rejected if item was not found.
     * @example
     * ```typescript
     * map.get('myKey')
     *   .then((item) => {
     *     console.log('Map SyncMapItem get() successful, item data:', item.data)
     *   })
     *   .catch((error) => {
     *     console.error('Map SyncMapItem get() failed', error);
     *   });
     * ```
     */

  }, {
    key: "get",
    value: function () {
      var _get3 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee16(key) {
        return _regeneratorRuntime__default['default'].wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                this.ensureNotClosed();
                return _context16.abrupt("return", this.syncMapImpl.get(key));

              case 2:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this);
      }));

      function get(_x31) {
        return _get3.apply(this, arguments);
      }

      return get;
    }()
    /**
     * Schedules a modification to this Map SyncMapItem that will apply a mutation function.
     * If no SyncMapItem with the given key exists, it will first be created, having the default data (`{}`).
     * @param key Selects the map item to be mutated.
     * @param mutator A function that outputs a new data based on the existing data.
     * May be called multiple times, particularly if this Map SyncMapItem is modified concurrently by remote code.
     * If the mutation ultimately succeeds, the Map SyncMapItem will have made the particular transition described
     * by this function.
     * @param itemMetadataUpdates New item metadata.
     * @return Resolves with the most recent item state, the output of a successful
     * mutation or a state that prompted graceful cancellation (mutator returned `null`).
     * @example
     * ```typescript
     * const mutatorFunction = (currentData) => {
     *     currentData.viewCount = (currentData.viewCount || 0) + 1;
     *     return currentData;
     * };
     * map.mutate('myKey', mutatorFunction, { ttl: 86400 })
     *   .then((item) => {
     *     console.log('Map SyncMapItem mutate() successful, new data:', item.data)
     *   })
     *   .catch((error) => {
     *     console.error('Map SyncMapItem mutate() failed', error);
     *   });
     * ```
     */

  }, {
    key: "mutate",
    value: function () {
      var _mutate2 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee17(key, mutator, itemMetadataUpdates) {
        return _regeneratorRuntime__default['default'].wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                this.ensureNotClosed();
                return _context17.abrupt("return", this.syncMapImpl.mutate(key, mutator, itemMetadataUpdates));

              case 2:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));

      function mutate(_x32, _x33, _x34) {
        return _mutate2.apply(this, arguments);
      }

      return mutate;
    }()
    /**
     * Modify a map item by appending new fields (or by overwriting existing ones) with the values from
     * the provided Object. Creates a new item if no item by this key exists, copying all given fields and values
     * into it.
     * This is equivalent to
     * ```typescript
     * map.mutate('myKey', (currentData) => Object.assign(currentData, obj));
     * ```
     * @param key Selects the map item to update.
     * @param obj Specifies the particular (top-level) attributes that will receive new values.
     * @param itemMetadataUpdates New item metadata.
     * @return A promise resolving to the modified item in its new state.
     * @example
     * ```typescript
     * // Say, the Map SyncMapItem (key: `'myKey'`) data is `{ name: 'John Smith' }`
     * map.update('myKey', { age: 34 }, { ttl: 86400 })
     *   .then((item) => {
     *     // Now the Map SyncMapItem data is `{ name: 'John Smith', age: 34 }`
     *     console.log('Map SyncMapItem update() successful, new data:', item.data);
     *   })
     *   .catch((error) => {
     *     console.error('Map SyncMapItem update() failed', error);
     *   });
     * ```
     */

  }, {
    key: "update",
    value: function () {
      var _update3 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee18(key, obj, itemMetadataUpdates) {
        return _regeneratorRuntime__default['default'].wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                this.ensureNotClosed();
                return _context18.abrupt("return", this.syncMapImpl.update(key, obj, itemMetadataUpdates));

              case 2:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this);
      }));

      function update(_x35, _x36, _x37) {
        return _update3.apply(this, arguments);
      }

      return update;
    }()
    /**
     * Delete an item, given its key.
     * @param key Selects the item to delete.
     * @return A promise to remove an item.
     * The promise will be rejected if 'key' is undefined or an item was not found.
     * @example
     * ```typescript
     * map.remove('myKey')
     *   .then(() => {
     *     console.log('Map SyncMapItem remove() successful');
     *   })
     *   .catch((error) => {
     *     console.error('Map SyncMapItem remove() failed', error);
     *   });
     * ```
     */

  }, {
    key: "remove",
    value: function () {
      var _remove2 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee19(key) {
        return _regeneratorRuntime__default['default'].wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                this.ensureNotClosed();
                return _context19.abrupt("return", this.syncMapImpl.remove(key));

              case 2:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19, this);
      }));

      function remove(_x38) {
        return _remove2.apply(this, arguments);
      }

      return remove;
    }()
    /**
     * Get a complete list of items from the map.
     * Information about the query limits can be found [here](https://www.twilio.com/docs/sync/limits).
     * @param queryOptions Query options.
     * @example
     * ```typescript
     * const pageHandler = (paginator) => {
     *   paginator.items.forEach((item) => {
     *     console.log(`SyncMapItem ${item.key}: `, item.data);
     *   });
     *   return paginator.hasNextPage
     *     ? paginator.nextPage().then(pageHandler)
     *     : null;
     * };
     * map.getItems({ from: 'myKey', order: 'asc' })
     *   .then(pageHandler)
     *   .catch((error) => {
     *     console.error('Map getItems() failed', error);
     *   });
     * ```
     */

  }, {
    key: "getItems",
    value: function () {
      var _getItems2 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee20(queryOptions) {
        return _regeneratorRuntime__default['default'].wrap(function _callee20$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:
                this.ensureNotClosed();
                return _context20.abrupt("return", this.syncMapImpl.getItems(queryOptions));

              case 2:
              case "end":
                return _context20.stop();
            }
          }
        }, _callee20, this);
      }));

      function getItems(_x39) {
        return _getItems2.apply(this, arguments);
      }

      return getItems;
    }()
    /**
     * Update the time-to-live of the map.
     * @param ttl Specifies the TTL in seconds after which the map is subject to automatic deletion. The value 0 means infinity.
     * @return A promise that resolves after the TTL update was successful.
     * @example
     * ```typescript
     * map.setTtl(3600)
     *   .then(() => {
     *     console.log('Map setTtl() successful');
     *   })
     *   .catch((error) => {
     *     console.error('Map setTtl() failed', error);
     *   });
     * ```
     */

  }, {
    key: "setTtl",
    value: function () {
      var _setTtl2 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee21(ttl) {
        return _regeneratorRuntime__default['default'].wrap(function _callee21$(_context21) {
          while (1) {
            switch (_context21.prev = _context21.next) {
              case 0:
                this.ensureNotClosed();
                return _context21.abrupt("return", this.syncMapImpl.setTtl(ttl));

              case 2:
              case "end":
                return _context21.stop();
            }
          }
        }, _callee21, this);
      }));

      function setTtl(_x40) {
        return _setTtl2.apply(this, arguments);
      }

      return setTtl;
    }()
    /**
     * Update the time-to-live of a map item.
     * @param key SyncMapItem key.
     * @param ttl Specifies the TTL in seconds after which the map item is subject to automatic deletion. The value 0 means infinity.
     * @return A promise that resolves after the TTL update was successful.
     * @example
     * ```typescript
     * map.setItemTtl('myKey', 86400)
     *   .then(() => {
     *     console.log('Map setItemTtl() successful');
     *   })
     *   .catch((error) => {
     *     console.error('Map setItemTtl() failed', error);
     *   });
     * ```
     */

  }, {
    key: "setItemTtl",
    value: function () {
      var _setItemTtl2 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee22(key, ttl) {
        return _regeneratorRuntime__default['default'].wrap(function _callee22$(_context22) {
          while (1) {
            switch (_context22.prev = _context22.next) {
              case 0:
                this.ensureNotClosed();
                return _context22.abrupt("return", this.syncMapImpl.setItemTtl(key, ttl));

              case 2:
              case "end":
                return _context22.stop();
            }
          }
        }, _callee22, this);
      }));

      function setItemTtl(_x41, _x42) {
        return _setItemTtl2.apply(this, arguments);
      }

      return setItemTtl;
    }()
    /**
     * Delete this map. It will be impossible to restore it.
     * @return A promise that resolves when the map has been deleted.
     * @example
     * ```typescript
     * map.removeMap()
     *   .then(() => {
     *     console.log('Map removeMap() successful');
     *   })
     *   .catch((error) => {
     *     console.error('Map removeMap() failed', error);
     *   });
     * ```
     */

  }, {
    key: "removeMap",
    value: function () {
      var _removeMap2 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee23() {
        return _regeneratorRuntime__default['default'].wrap(function _callee23$(_context23) {
          while (1) {
            switch (_context23.prev = _context23.next) {
              case 0:
                this.ensureNotClosed();
                _context23.next = 3;
                return this.syncMapImpl.removeMap();

              case 3:
              case "end":
                return _context23.stop();
            }
          }
        }, _callee23, this);
      }));

      function removeMap() {
        return _removeMap2.apply(this, arguments);
      }

      return removeMap;
    }()
    /**
     * Conclude work with the map instance and remove all event listeners attached to it.
     * Any subsequent operation on this object will be rejected with error.
     * Other local copies of this map will continue operating and receiving events normally.
     * @example
     * ```typescript
     * map.close();
     * ````
     */

  }, {
    key: "close",
    value: function close() {
      _get__default['default'](_getPrototypeOf__default['default'](SyncMap.prototype), "close", this).call(this);

      this.syncMapImpl.detach(this.listenerUuid);
    }
  }], [{
    key: "type",
    get: function get() {
      return SyncMapImpl.type;
    }
  }]);

  return SyncMap;
}(Closeable);

_defineProperty__default['default'](SyncMap, "itemAdded", 'itemAdded');

_defineProperty__default['default'](SyncMap, "itemUpdated", 'itemUpdated');

_defineProperty__default['default'](SyncMap, "itemRemoved", 'itemRemoved');

_defineProperty__default['default'](SyncMap, "removed", 'removed');

__decorate([declarativeTypeValidator.validateTypesAsync('string', declarativeTypeValidator.pureObject, ['undefined', declarativeTypeValidator.objectSchema('item metadata', {
  ttl: [declarativeTypeValidator.nonNegativeInteger, 'undefined']
})]), __metadata("design:type", Function), __metadata("design:paramtypes", [String, Object, Object]), __metadata("design:returntype", Promise)], SyncMap.prototype, "set", null);

__decorate([declarativeTypeValidator.validateTypesAsync('string'), __metadata("design:type", Function), __metadata("design:paramtypes", [String]), __metadata("design:returntype", Promise)], SyncMap.prototype, "get", null);

__decorate([declarativeTypeValidator.validateTypesAsync('string', 'function', ['undefined', declarativeTypeValidator.objectSchema('item metadata', {
  ttl: [declarativeTypeValidator.nonNegativeInteger, 'undefined']
})]), __metadata("design:type", Function), __metadata("design:paramtypes", [String, Function, Object]), __metadata("design:returntype", Promise)], SyncMap.prototype, "mutate", null);

__decorate([declarativeTypeValidator.validateTypesAsync('string', declarativeTypeValidator.pureObject, ['undefined', declarativeTypeValidator.objectSchema('item metadata', {
  ttl: [declarativeTypeValidator.nonNegativeInteger, 'undefined']
})]), __metadata("design:type", Function), __metadata("design:paramtypes", [String, Object, Object]), __metadata("design:returntype", Promise)], SyncMap.prototype, "update", null);

__decorate([declarativeTypeValidator.validateTypesAsync('string'), __metadata("design:type", Function), __metadata("design:paramtypes", [String]), __metadata("design:returntype", Promise)], SyncMap.prototype, "remove", null);

__decorate([declarativeTypeValidator.validateTypesAsync(['undefined', declarativeTypeValidator.objectSchema('query options', {
  from: ['string', 'undefined'],
  pageSize: [declarativeTypeValidator.custom(function (value) {
    return [isPositiveInteger(value), 'a positive integer'];
  }), 'undefined']
})]), __metadata("design:type", Function), __metadata("design:paramtypes", [Object]), __metadata("design:returntype", Promise)], SyncMap.prototype, "getItems", null);

__decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonNegativeInteger), __metadata("design:type", Function), __metadata("design:paramtypes", [Number]), __metadata("design:returntype", Promise)], SyncMap.prototype, "setTtl", null);

__decorate([declarativeTypeValidator.validateTypesAsync('string', declarativeTypeValidator.nonNegativeInteger), __metadata("design:type", Function), __metadata("design:paramtypes", [String, Number]), __metadata("design:returntype", Promise)], SyncMap.prototype, "setItemTtl", null);

function _createSuper$2(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$2(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

function _isNativeReflectConstruct$2() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var SyncStreamImpl = /*#__PURE__*/function (_SyncEntity) {
  _inherits__default['default'](SyncStreamImpl, _SyncEntity);

  var _super = _createSuper$2(SyncStreamImpl);

  /**
   * @internal
   */
  function SyncStreamImpl(services, descriptor, removalHandler) {
    var _this;

    _classCallCheck__default['default'](this, SyncStreamImpl);

    _this = _super.call(this, services, removalHandler);
    _this.descriptor = descriptor;
    return _this;
  } // private props


  _createClass__default['default'](SyncStreamImpl, [{
    key: "uri",
    get: function get() {
      return this.descriptor.url;
    }
  }, {
    key: "links",
    get: function get() {
      return this.descriptor.links;
    }
  }, {
    key: "dateExpires",
    get: function get() {
      return this.descriptor.date_expires;
    }
  }, {
    key: "type",
    get: function get() {
      return 'stream';
    }
  }, {
    key: "lastEventId",
    get: function get() {
      return null;
    } // below properties are specific to Insights only

  }, {
    key: "indexName",
    get: function get() {
      return undefined;
    }
  }, {
    key: "queryString",
    get: function get() {
      return undefined;
    } // public props, documented along with class description

  }, {
    key: "sid",
    get: function get() {
      return this.descriptor.sid;
    }
  }, {
    key: "uniqueName",
    get: function get() {
      return this.descriptor.unique_name || null;
    }
  }, {
    key: "publishMessage",
    value: function () {
      var _publishMessage = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee(data) {
        var requestBody, response, responseBody, event;
        return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                requestBody = {
                  data: data
                };
                _context.next = 3;
                return this.services.network.post(this.links.messages, requestBody);

              case 3:
                response = _context.sent;
                responseBody = response.body;
                event = this._handleMessagePublished(responseBody.sid, data, false);
                return _context.abrupt("return", event);

              case 7:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function publishMessage(_x) {
        return _publishMessage.apply(this, arguments);
      }

      return publishMessage;
    }()
  }, {
    key: "setTtl",
    value: function () {
      var _setTtl = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee2(ttl) {
        var requestBody, response;
        return _regeneratorRuntime__default['default'].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.prev = 0;
                requestBody = {
                  ttl: ttl
                };
                _context2.next = 4;
                return this.services.network.post(this.uri, requestBody);

              case 4:
                response = _context2.sent;
                this.descriptor.date_expires = response.body.date_expires;
                _context2.next = 12;
                break;

              case 8:
                _context2.prev = 8;
                _context2.t0 = _context2["catch"](0);

                if (_context2.t0.status === 404) {
                  this.onRemoved(false);
                }

                throw _context2.t0;

              case 12:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[0, 8]]);
      }));

      function setTtl(_x2) {
        return _setTtl.apply(this, arguments);
      }

      return setTtl;
    }()
  }, {
    key: "removeStream",
    value: function () {
      var _removeStream = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee3() {
        return _regeneratorRuntime__default['default'].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.services.network.delete(this.uri);

              case 2:
                this.onRemoved(true);

              case 3:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function removeStream() {
        return _removeStream.apply(this, arguments);
      }

      return removeStream;
    }()
    /**
     * Handle event from the server
     * @private
     */

  }, {
    key: "_update",
    value: function _update(update) {
      switch (update.type) {
        case 'stream_message_published':
          {
            this._handleMessagePublished(update.message_sid, update.message_data, true);

            break;
          }

        case 'stream_removed':
          {
            this.onRemoved(false);
            break;
          }
      }
    }
  }, {
    key: "_handleMessagePublished",
    value: function _handleMessagePublished(sid, data, remote) {
      var event = {
        sid: sid,
        data: data
      };
      this.broadcastEventToListeners('messagePublished', {
        message: event,
        isLocal: !remote
      });
      return event;
    }
  }, {
    key: "onRemoved",
    value: function onRemoved(isLocal) {
      this._unsubscribe();

      this.removalHandler(this.type, this.sid, this.uniqueName);
      this.broadcastEventToListeners('removed', {
        isLocal: isLocal
      });
    }
  }], [{
    key: "type",
    get: function get() {
      return 'stream';
    }
  }]);

  return SyncStreamImpl;
}(SyncEntity);

__decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.pureObject), __metadata("design:type", Function), __metadata("design:paramtypes", [Object]), __metadata("design:returntype", Promise)], SyncStreamImpl.prototype, "publishMessage", null);

__decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonNegativeInteger), __metadata("design:type", Function), __metadata("design:paramtypes", [Number]), __metadata("design:returntype", Promise)], SyncStreamImpl.prototype, "setTtl", null);
/**
 * A Sync primitive for pub-sub messaging. Stream Messages are not persisted, exist
 * only in transit, and will be dropped if (due to congestion or network anomalies) they
 * cannot be delivered promptly. Use the {@link SyncClient.stream} method to obtain a reference to a Sync Message Stream.
 * Information about rate limits can be found [here](https://www.twilio.com/docs/sync/limits).
 */


var SyncStream = /*#__PURE__*/function (_Closeable) {
  _inherits__default['default'](SyncStream, _Closeable);

  var _super2 = _createSuper$2(SyncStream);

  /**
   * @internal
   */
  function SyncStream(syncStreamImpl) {
    var _this2;

    _classCallCheck__default['default'](this, SyncStream);

    _this2 = _super2.call(this);
    _this2.syncStreamImpl = syncStreamImpl;

    _this2.syncStreamImpl.attach(_assertThisInitialized__default['default'](_this2));

    return _this2;
  }
  /**
   * Fired when a message is published to the stream either locally or by a remote actor.
   *
   * Parameters:
   * 1. object `args` - info object provided with the event. It has the following properties:
   *     * {@link SyncStreamMessage} `message` -  Published message
   *     * boolean `isLocal` - equals true if the message was published by a local actor, false otherwise
   * @example
   * ```typescript
   * stream.on('messagePublished', (args) => {
   *   console.log('Stream message published');
   *   console.log('Message SID:', args.message.sid);
   *   console.log('Message data: ', args.message.data);
   *   console.log('args.isLocal:', args.isLocal);
   * });
   * ```
   * @event
   */


  _createClass__default['default'](SyncStream, [{
    key: "uri",
    get: // private props
    function get() {
      return this.syncStreamImpl.uri;
    }
  }, {
    key: "links",
    get: function get() {
      return this.syncStreamImpl.links;
    }
  }, {
    key: "dateExpires",
    get: function get() {
      return this.syncStreamImpl.dateExpires;
    }
  }, {
    key: "type",
    get: function get() {
      return SyncStreamImpl.type;
    }
  }, {
    key: "lastEventId",
    get: function get() {
      return null;
    }
    /**
     * The immutable system-assigned identifier of this stream. Never null.
     */

  }, {
    key: "sid",
    get: function get() {
      return this.syncStreamImpl.sid;
    }
    /**
     * A unique identifier optionally assigned to the stream on creation.
     */

  }, {
    key: "uniqueName",
    get: function get() {
      return this.syncStreamImpl.uniqueName;
    }
  }, {
    key: "publishMessage",
    value:
    /**
     * Publish a message to the stream. The system will attempt delivery to all online subscribers.
     * @param data The body of the dispatched message. Maximum size in serialized JSON: 4KB.
     * A rate limit applies to this operation, refer to the [Sync API documentation](https://www.twilio.com/docs/api/sync) for details.
     * @return A promise which resolves after the message is successfully published
     * to the Sync service. Resolves irrespective of ultimate delivery to any subscribers.
     * @example
     * ```typescript
     * stream.publishMessage({ x: 42, y: 123 })
     *   .then((message) => {
     *     console.log('Stream publishMessage() successful, message SID:', message.sid);
     *   })
     *   .catch((error) => {
     *     console.error('Stream publishMessage() failed', error);
     *   });
     * ```
     */
    function () {
      var _publishMessage2 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee4(data) {
        return _regeneratorRuntime__default['default'].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                this.ensureNotClosed();
                return _context4.abrupt("return", this.syncStreamImpl.publishMessage(data));

              case 2:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function publishMessage(_x3) {
        return _publishMessage2.apply(this, arguments);
      }

      return publishMessage;
    }()
    /**
     * Update the time-to-live of the stream.
     * @param ttl Specifies the TTL in seconds after which the stream is subject to automatic deletion. The value 0 means infinity.
     * @return A promise that resolves after the TTL update was successful.
     * @example
     * ```typescript
     * stream.setTtl(3600)
     *   .then(() => {
     *     console.log('Stream setTtl() successful');
     *   })
     *   .catch((error) => {
     *     console.error('Stream setTtl() failed', error);
     *   });
     * ```
     */

  }, {
    key: "setTtl",
    value: function () {
      var _setTtl2 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee5(ttl) {
        return _regeneratorRuntime__default['default'].wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                this.ensureNotClosed();
                return _context5.abrupt("return", this.syncStreamImpl.setTtl(ttl));

              case 2:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function setTtl(_x4) {
        return _setTtl2.apply(this, arguments);
      }

      return setTtl;
    }()
    /**
     * Permanently delete this Stream.
     * @return A promise which resolves after the Stream is successfully deleted.
     * @example
     * ```typescript
     * stream.removeStream()
     *   .then(() => {
     *     console.log('Stream removeStream() successful');
     *   })
     *   .catch((error) => {
     *     console.error('Stream removeStream() failed', error);
     *   });
     * ```
     */

  }, {
    key: "removeStream",
    value: function () {
      var _removeStream2 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee6() {
        return _regeneratorRuntime__default['default'].wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                this.ensureNotClosed();
                return _context6.abrupt("return", this.syncStreamImpl.removeStream());

              case 2:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function removeStream() {
        return _removeStream2.apply(this, arguments);
      }

      return removeStream;
    }()
    /**
     * Conclude work with the stream instance and remove all event listeners attached to it.
     * Any subsequent operation on this object will be rejected with error.
     * Other local copies of this stream will continue operating and receiving events normally.
     * @example
     * ```typescript
     * stream.close();
     * ```
     */

  }, {
    key: "close",
    value: function close() {
      _get__default['default'](_getPrototypeOf__default['default'](SyncStream.prototype), "close", this).call(this);

      this.syncStreamImpl.detach(this.listenerUuid);
    }
  }], [{
    key: "type",
    get: function get() {
      return SyncStreamImpl.type;
    }
  }]);

  return SyncStream;
}(Closeable);

_defineProperty__default['default'](SyncStream, "messagePublished", 'messagePublished');

_defineProperty__default['default'](SyncStream, "removed", 'removed');

__decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.pureObject), __metadata("design:type", Function), __metadata("design:paramtypes", [Object]), __metadata("design:returntype", Promise)], SyncStream.prototype, "publishMessage", null);

__decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonNegativeInteger), __metadata("design:type", Function), __metadata("design:paramtypes", [Number]), __metadata("design:returntype", Promise)], SyncStream.prototype, "setTtl", null);

var ClientInfo = function ClientInfo(version) {
  _classCallCheck__default['default'](this, ClientInfo);

  this.sdk = 'js';
  this.sdkVer = version;
  this.os = platform__namespace.os.family;
  this.osVer = platform__namespace.os.version;
  this.pl = platform__namespace.name;
  this.plVer = platform__namespace.version;
};

/**
 * Container for entities which are known by the client
 * It's needed for deduplication when client obtain the same object several times
 */
var EntitiesCache = /*#__PURE__*/function () {
  function EntitiesCache() {
    _classCallCheck__default['default'](this, EntitiesCache);

    this.names = new Map();
    this.entities = new Map();
  }

  _createClass__default['default'](EntitiesCache, [{
    key: "store",
    value: function store(entity) {
      var stored = this.entities.get(entity.sid);

      if (stored) {
        return stored;
      }

      this.entities.set(entity.sid, entity);

      if (entity.uniqueName) {
        this.names.set(entity.type + '::' + entity.uniqueName, entity.sid);
      }

      return entity;
    }
  }, {
    key: "getResolved",
    value: function getResolved(id, type) {
      var resolvedSid = this.names.get(type + '::' + id);
      return resolvedSid ? this.entities.get(resolvedSid) : null;
    }
  }, {
    key: "get",
    value: function get(id, type) {
      return this.entities.get(id) || this.getResolved(id, type) || null;
    }
  }, {
    key: "remove",
    value: function remove(sid) {
      var cached = this.entities.get(sid);

      if (cached) {
        this.entities.delete(sid);

        if (cached.uniqueName) {
          this.names.delete(cached.type + '::' + cached.uniqueName);
        }
      }
    }
  }]);

  return EntitiesCache;
}();

function _createSuper$1(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

function _isNativeReflectConstruct$1() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * An individual result from a LiveQuery or InstantQuery result set.
 */

var InsightsItem =
/**
 * @internal
 */
function InsightsItem() {
  _classCallCheck__default['default'](this, InsightsItem);
}
/**
 * The identifier that maps to this item within the search result.
 */
;
var LiveQueryImpl = /*#__PURE__*/function (_SyncEntity) {
  _inherits__default['default'](LiveQueryImpl, _SyncEntity);

  var _super = _createSuper$1(LiveQueryImpl);

  function LiveQueryImpl(descriptor, services, removalHandler, items) {
    var _this;

    _classCallCheck__default['default'](this, LiveQueryImpl);

    _this = _super.call(this, services, removalHandler);
    _this.descriptor = descriptor;
    _this.cache = new Cache();

    if (items) {
      items.forEach(function (item) {
        _this.cache.store(item.key, {
          key: item.key,
          value: item.data
        }, item.revision);
      });
    }

    return _this;
  } // public


  _createClass__default['default'](LiveQueryImpl, [{
    key: "sid",
    get: function get() {
      return this.descriptor.sid;
    } // private extension of SyncEntity

  }, {
    key: "uniqueName",
    get: function get() {
      return null;
    }
  }, {
    key: "type",
    get: function get() {
      return LiveQueryImpl.type;
    }
  }, {
    key: "lastEventId",
    get: function get() {
      return this.descriptor.last_event_id;
    }
  }, {
    key: "indexName",
    get: function get() {
      return this.descriptor.indexName;
    }
  }, {
    key: "queryString",
    get: function get() {
      return this.descriptor.queryExpression;
    } // custom private props

  }, {
    key: "queryUri",
    get: function get() {
      return this.descriptor.queryUri;
    }
  }, {
    key: "liveQueryDescriptor",
    get: function get() {
      return this.descriptor;
    } // dummy stub from iface

  }, {
    key: "onRemoved",
    value: function onRemoved() {}
  }, {
    key: "getItems",
    value: function getItems() {
      var dataByKey = {};
      this.cache.forEach(function (key, item) {
        dataByKey[key] = item.value;
      });
      return dataByKey;
    }
    /**
     * @internal
     */

  }, {
    key: "_update",
    value: function _update(message, isStrictlyOrdered) {
      switch (message.type) {
        case 'live_query_item_updated':
          this.handleItemMutated(message.item_key, message.item_data, message.item_revision);
          break;

        case 'live_query_item_removed':
          this.handleItemRemoved(message.item_key, message.item_revision);
          break;

        case 'live_query_updated':
          this.handleBatchUpdate(message.items);
          break;
      }

      if (isStrictlyOrdered) {
        this._advanceLastEventId(message.last_event_id);
      }
    }
  }, {
    key: "handleItemMutated",
    value: function handleItemMutated(key, value, revision) {
      if (this.shouldIgnoreEvent(key, revision)) {
        log$1.trace("Item ".concat(key, " update skipped, revision: ").concat(revision));
      } else {
        var newItem = {
          key: key,
          value: value
        };
        this.cache.store(key, newItem, revision);
        this.broadcastEventToListeners('itemUpdated', newItem);
      }
    }
  }, {
    key: "handleItemRemoved",
    value: function handleItemRemoved(key, revision) {
      var force = revision === null;

      if (this.shouldIgnoreEvent(key, revision)) {
        log$1.trace("Item ".concat(key, " delete skipped, revision: ").concat(revision));
      } else {
        this.cache.delete(key, revision, force);
        this.broadcastEventToListeners('itemRemoved', {
          key: key
        });
      }
    }
  }, {
    key: "handleBatchUpdate",
    value: function handleBatchUpdate(items) {
      var _this2 = this;

      // preprocess item set for easy key-based access (it's a one-time constant time operation)
      var newItems = {};

      if (items != null) {
        items.forEach(function (item) {
          newItems[item.key] = {
            data: item.data,
            revision: item.revision
          };
        });
      } // go through existing items and generate update/remove events for them


      this.cache.forEach(function (key, item) {
        var newItem = newItems[key];

        if (newItem != null) {
          _this2.handleItemMutated(key, newItem.data, newItem.revision);
        } else {
          _this2.handleItemRemoved(key, null); // force deletion w/o revision

        } // once item is handled, remove it from incoming array


        delete newItems[key];
      }); // once we handled all the known items, handle remaining pack

      for (var key in newItems) {
        this.handleItemMutated(key, newItems[key].data, newItems[key].revision);
      }
    }
  }, {
    key: "shouldIgnoreEvent",
    value: function shouldIgnoreEvent(key, eventId) {
      return key != null && eventId != null && this.cache.isKnown(key, eventId);
    }
    /**
     * @internal
     */

  }, {
    key: "_advanceLastEventId",
    value: function _advanceLastEventId(eventId, revision) {
      // LiveQuery is not revisioned in any way, so simply ignore second param and act upon lastEventId only
      if (this.lastEventId < eventId) {
        this.descriptor.last_event_id = eventId;
      }
    }
  }], [{
    key: "type",
    get: function get() {
      return 'live_query';
    }
  }]);

  return LiveQueryImpl;
}(SyncEntity);
function queryItems(_x) {
  return _queryItems.apply(this, arguments);
}
/**
 * Represents a long-running query against Flex data wherein the returned result set
 * subsequently receives pushed updates whenever new (or updated) records would match the
 * given expression. Updated results are presented row-by-row until this query is explicitly
 * closed.
 *
 * Use the {@link SyncClient.liveQuery} method to create a live query.
 */

function _queryItems() {
  _queryItems = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee3(params) {
    var network, queryString, uri, type, liveQueryRequestBody, response;
    return _regeneratorRuntime__default['default'].wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            network = params.network, queryString = params.queryString, uri = params.uri, type = params.type;

            if (!(queryString == null)) {
              _context3.next = 3;
              break;
            }

            throw new SyncError("Invalid query", 400, 54507);

          case 3:
            liveQueryRequestBody = {
              query_string: queryString // raw query string (like `key == "value" AND key2 != "value2"`)

            };

            if (type === LiveQuery.type) {
              liveQueryRequestBody.type = type;
            }

            _context3.next = 7;
            return network.post(uri, liveQueryRequestBody, undefined, true);

          case 7:
            response = _context3.sent;
            return _context3.abrupt("return", response.body);

          case 9:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _queryItems.apply(this, arguments);
}

var LiveQuery = /*#__PURE__*/function (_Closeable) {
  _inherits__default['default'](LiveQuery, _Closeable);

  var _super2 = _createSuper$1(LiveQuery);

  /**
   * @internal
   */
  function LiveQuery(liveQueryImpl) {
    var _this3;

    _classCallCheck__default['default'](this, LiveQuery);

    _this3 = _super2.call(this);
    _this3.liveQueryImpl = liveQueryImpl;

    _this3.liveQueryImpl.attach(_assertThisInitialized__default['default'](_this3));

    return _this3;
  }
  /**
   * Fired when an item has been added or updated.
   *
   * Parameters:
   * 1. {@link InsightsItem} `item` - updated item
   * @example
   * ```typescript
   * liveQuery.on('itemUpdated', (item) => {
   *   console.log(`Item ${item.key} was updated`'`);
   *   console.log('Item value:', item.value);
   * });
   * ```
   * @event
   */


  _createClass__default['default'](LiveQuery, [{
    key: "type",
    get: function get() {
      return LiveQueryImpl.type;
    }
  }, {
    key: "lastEventId",
    get: function get() {
      return this.liveQueryImpl.lastEventId;
    }
    /**
     * The immutable identifier of this query object, assigned by the system.
     */

  }, {
    key: "sid",
    get: function get() {
      return this.liveQueryImpl.sid;
    }
  }, {
    key: "close",
    value:
    /**
     * Closes this query instance and unsubscribes from further service events.
     * This will eventually stop the physical inflow of updates over the network, when all other instances of this query are closed as well.
     */
    function close() {
      _get__default['default'](_getPrototypeOf__default['default'](LiveQuery.prototype), "close", this).call(this);

      this.liveQueryImpl.detach(this.listenerUuid);
    }
    /**
     * @return A snapshot of items matching the current query expression.
     */

  }, {
    key: "getItems",
    value: function getItems() {
      this.ensureNotClosed();
      return this.liveQueryImpl.getItems();
    }
  }], [{
    key: "type",
    get: // private props
    function get() {
      return LiveQueryImpl.type;
    }
  }]);

  return LiveQuery;
}(Closeable);
/**
 * Allows repetitive quick searches against a specific Flex data. Unlike a
 * LiveQuery, this result set does not subscribe to any updates and therefore receives no events
 * beyond the initial result set.
 *
 * Use the {@link SyncClient.instantQuery} method to create an Instant Query.
 */

_defineProperty__default['default'](LiveQuery, "itemUpdated", 'itemUpdated');

_defineProperty__default['default'](LiveQuery, "itemRemoved", 'itemRemoved');

var InstantQuery = /*#__PURE__*/function (_EventEmitter) {
  _inherits__default['default'](InstantQuery, _EventEmitter);

  var _super3 = _createSuper$1(InstantQuery);

  /**
   * @internal
   */
  function InstantQuery(params) {
    var _this4;

    _classCallCheck__default['default'](this, InstantQuery);

    _this4 = _super3.call(this);

    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this4), "queryExpression", null);

    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this4), "items", {});

    Object.assign(_assertThisInitialized__default['default'](_this4), params);

    _this4.updateIndexName(params.indexName);

    return _this4;
  }
  /**
   * Fired when a search result is ready.
   *
   * Parameters:
   * 1. {@link ItemsSnapshot} `items` - a snapshot of items matching current query expression.
   * @example
   * ```typescript
   * instantQuery.on('searchResult', (items) => {
   *    Object.entries(items).forEach(([key, value]) => {
   *      console.log('Search result item key:', key);
   *      console.log('Search result item value:', value);
   *    });
   * });
   * ```
   * @event
   */


  _createClass__default['default'](InstantQuery, [{
    key: "type",
    get: function get() {
      return InstantQuery.type;
    }
  }, {
    key: "search",
    value:
    /**
     * Spawns a new search request. The result will be provided asynchronously via the {@link InstantQuery.searchResult}
     * event.
     * @param queryExpression A query expression to be executed against the given data index. For more information
     * on the syntax read {@link SyncClient.liveQuery}.
     * @return A promise that resolves when query result has been received.
     */
    function () {
      var _search = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee(queryExpression) {
        var _this5 = this;

        return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                this.items = {};
                return _context.abrupt("return", queryItems({
                  network: this.network,
                  uri: this.queryUri,
                  queryString: queryExpression
                }).then(function (response) {
                  _this5.queryExpression = queryExpression;

                  if (response.items) {
                    response.items.forEach(function (item) {
                      _this5.items[item.key] = item.data;
                    });
                  }

                  _this5.emit('searchResult', _this5.getItems());
                }).catch(function (err) {
                  log$1.error("Error '".concat(err.message, "' while executing query '").concat(queryExpression, "'"));
                  _this5.queryExpression = null;
                  throw err;
                }));

              case 2:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function search(_x2) {
        return _search.apply(this, arguments);
      }

      return search;
    }()
    /**
     * Instantiates a LiveQuery object based on the last known query expression that was passed to the
     * {@link InstantQuery.search} method. This LiveQuery will start receiving updates with new results,
     * while current object can be still used to execute repetitive searches.
     * @return A promise which resolves when the LiveQuery object is ready.
     */

  }, {
    key: "subscribe",
    value: function () {
      var _subscribe = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee2() {
        return _regeneratorRuntime__default['default'].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!(this.queryExpression == null)) {
                  _context2.next = 2;
                  break;
                }

                return _context2.abrupt("return", Promise.reject(new SyncError("Invalid query", 400, 54507)));

              case 2:
                return _context2.abrupt("return", this.liveQueryCreator(this.indexName, this.queryExpression));

              case 3:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function subscribe() {
        return _subscribe.apply(this, arguments);
      }

      return subscribe;
    }()
    /**
     * @return A snapshot of items matching current query expression.
     */

  }, {
    key: "getItems",
    value: function getItems() {
      return this.items;
    }
    /**
     * Set new index name
     * @param indexName New index name to set
     */

  }, {
    key: "updateIndexName",
    value: function updateIndexName(indexName) {
      this.indexName = indexName;
      this.queryUri = this.generateQueryUri(this.indexName);
    }
  }, {
    key: "generateQueryUri",
    value: function generateQueryUri(indexName) {
      return new UriBuilder(this.insightsUri).pathSegment(indexName).pathSegment('Items').build();
    }
  }], [{
    key: "type",
    get: // private props
    function get() {
      return 'instant_query';
    }
  }]);

  return InstantQuery;
}(EventEmitter);

_defineProperty__default['default'](InstantQuery, "searchResult", 'searchResult');

__decorate([declarativeTypeValidator.validateTypesAsync('string'), __metadata("design:type", Function), __metadata("design:paramtypes", [String]), __metadata("design:returntype", Promise)], InstantQuery.prototype, "search", null);

__decorate([declarativeTypeValidator.validateTypes(declarativeTypeValidator.nonEmptyString), __metadata("design:type", Function), __metadata("design:paramtypes", [String]), __metadata("design:returntype", void 0)], InstantQuery.prototype, "updateIndexName", null);

var version = "3.1.0";

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty__default['default'](target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var SYNC_PRODUCT_ID = 'data_sync';
var SDK_VERSION = version;

function decompose(arg) {
  if (!arg) {
    return {
      mode: 'create_new'
    };
  } else if (typeof arg === 'string') {
    return {
      id: arg,
      mode: 'open_or_create'
    };
  } else {
    var mode = arg.mode || (arg.id ? 'open_or_create' : 'create_new');
    return _objectSpread(_objectSpread({}, arg), {}, {
      mode: mode
    });
  }
}

var SYNC_DOCUMENT_NOTIFICATION_TYPE = 'com.twilio.rtd.cds.document';
var SYNC_LIST_NOTIFICATION_TYPE = 'com.twilio.rtd.cds.list';
var SYNC_MAP_NOTIFICATION_TYPE = 'com.twilio.rtd.cds.map';
var SYNC_NOTIFICATION_TYPE = 'twilio.sync.event';
/**
 * Client for the Twilio Sync service.
 *
 * @example
 * ```typescript
 * // Using NPM resolution
 * const SyncClient = require('twilio-sync');
 * const syncClient = new SyncClient(token, { loglevel: 'debug' });
 *
 * // Using CDN
 * const syncClient = new Twilio.Sync.Client(token, { logLevel: 'debug' });
 * ```
 */

var Client = /*#__PURE__*/function (_EventEmitter) {
  _inherits__default['default'](Client, _EventEmitter);

  var _super = _createSuper(Client);

  /**
   * @param fpaToken Twilio access token.
   * @param options Options to customize the client.
   */
  function Client(fpaToken) {
    var _this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck__default['default'](this, Client);

    _this = _super.call(this);

    if (!fpaToken) {
      throw new Error('Sync library needs a valid Twilio token to be passed');
    }

    if (options.hasOwnProperty('logLevel')) {
      log$1.setLevel(options.logLevel);
    } else {
      log$1.setLevel('silent');
    }

    var productId = options.productId = options.productId || SYNC_PRODUCT_ID; // Fill ClientMetadata

    options.clientMetadata = options.clientMetadata || {};

    if (!options.clientMetadata.hasOwnProperty('type')) {
      options.clientMetadata.type = 'sync';
    }

    if (!options.clientMetadata.hasOwnProperty('sdk')) {
      options.clientMetadata.sdk = 'JS';
      options.clientMetadata.sdkv = SDK_VERSION;
    }

    var startTwilsock = !options.twilsockClient; // Create default init registrations if none were provided.
    // Otherwise, the outside party have to list all the init registrations they need, including Sync ones.

    if (!options.initRegistrations) {
      var initRegistration = new twilsock.InitRegistration(productId);
      Client.populateInitRegistrations(initRegistration);
      options.initRegistrations = [initRegistration];
    }

    var twilsock$1 = options.twilsockClient = options.twilsockClient || new twilsock.Twilsock(fpaToken, productId, options);
    twilsock$1.on('tokenAboutToExpire', function (ttl) {
      return _this.emit('tokenAboutToExpire', ttl);
    });
    twilsock$1.on('tokenExpired', function () {
      return _this.emit('tokenExpired');
    });
    twilsock$1.on('connectionError', function (err) {
      return _this.emit('connectionError', err);
    });
    twilsock$1.on('stateChanged', function (state) {
      _this.emit('connectionStateChanged', state);
      /**
       * Handle transport establishing event
       * If we have any subscriptions - we should check object for modifications
       */


      _this.services.subscriptions.onConnectionStateChanged(state === 'connected');
    });
    twilsock$1.on('message', function (messageType, payload) {
      return _this._routeMessage(messageType, payload);
    });
    var config = new Configuration(options);
    var network = new NetworkService(new ClientInfo(SDK_VERSION), config, twilsock$1);
    var storage = new SessionStorage(config);
    _this.services = {
      config: config,
      twilsock: twilsock$1,
      network: network,
      storage: storage,
      router: _assertThisInitialized__default['default'](_this),
      subscriptions: null
    };
    _this.services.subscriptions = new Subscriptions(_this.services);
    _this.entities = new EntitiesCache(); // Start only if we created twilsock locally,
    // otherwise it's the responsibility of whoever created the Twilsock client.

    if (startTwilsock) {
      twilsock$1.connect();
    }

    return _this;
  }
  /**
   * Fired when connection state has been changed.
   *
   * Parameters:
   * 1. {@link ConnectionState} `connectionState` - contains current service connection state.
   * @example
   * ```typescript
   * syncClient.on('connectionStateChanged', (newState) => {
   *   console.log('Received a new connection state:', newState);
   * });
   * ```
   * @event
   */


  _createClass__default['default'](Client, [{
    key: "_routeMessage",
    value:
    /**
     * Entry point for all the incoming messages (Router).
     *
     * @param type Type of the incoming message
     * @param message Message to route
     * @internal
     */
    function _routeMessage(type, message) {
      log$1.trace('Notification type:', type, 'content:', message);

      switch (type) {
        case SYNC_DOCUMENT_NOTIFICATION_TYPE:
        case SYNC_LIST_NOTIFICATION_TYPE:
        case SYNC_MAP_NOTIFICATION_TYPE:
          this.services.subscriptions.acceptMessage(message, false);
          break;

        case SYNC_NOTIFICATION_TYPE:
          this.services.subscriptions.acceptMessage(message, true);
          break;
      }
    }
    /**
     * Subscribe for events (Router)
     *
     * @internal
     */

  }, {
    key: "_subscribe",
    value: function _subscribe(sid, entity) {
      this.services.subscriptions.add(sid, entity);
    }
    /**
     * Unsubscribe from events (Router)
     *
     * @internal
     */

  }, {
    key: "_unsubscribe",
    value: function _unsubscribe(sid) {
      this.services.subscriptions.remove(sid);
    }
    /**
     * Current version of the Sync client.
     */

  }, {
    key: "connectionState",
    get:
    /**
     * Current service connection state.
     */
    function get() {
      return this.services.twilsock.state;
    }
    /**
     * Returns a promise which resolves when library is correctly initialized
     * Or throws if initialization is impossible
     *
     * @internal
     */

  }, {
    key: "ensureReady",
    value: function () {
      var _ensureReady = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee() {
        var storageSettings;
        return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (this.services.config.sessionStorageEnabled) {
                  _context.next = 2;
                  break;
                }

                return _context.abrupt("return");

              case 2:
                _context.prev = 2;
                _context.next = 5;
                return this.services.twilsock.storageId();

              case 5:
                storageSettings = _context.sent;
                this.services.storage.updateStorageId(storageSettings.id);
                _context.next = 12;
                break;

              case 9:
                _context.prev = 9;
                _context.t0 = _context["catch"](2);
                log$1.warn('Failed to initialize storage', _context.t0);

              case 12:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[2, 9]]);
      }));

      function ensureReady() {
        return _ensureReady.apply(this, arguments);
      }

      return ensureReady;
    }()
  }, {
    key: "storeRootInSessionCache",
    value: function storeRootInSessionCache(type, id, value) {
      // can't store without id
      if (!this.services.config.sessionStorageEnabled || !id) {
        return;
      }

      var valueToStore = deepClone(value);

      if (type === SyncList.type || type === SyncMap.type) {
        valueToStore['last_event_id'] = null;
        delete valueToStore['items'];
      }

      this.services.storage.store(type, id, valueToStore);
    }
  }, {
    key: "readRootFromSessionCache",
    value: function readRootFromSessionCache(type, id) {
      if (!this.services.config.sessionStorageEnabled || !id) {
        return null;
      }

      return this.services.storage.read(type, id);
    }
  }, {
    key: "_get",
    value: function () {
      var _get2 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee2(baseUri, id) {
        var optimistic,
            uri,
            response,
            _args2 = arguments;
        return _regeneratorRuntime__default['default'].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                optimistic = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : false;

                if (id) {
                  _context2.next = 3;
                  break;
                }

                throw new SyncError("Cannot get entity without id", 404);

              case 3:
                uri = new UriBuilder(baseUri).pathSegment(id).queryParam('Include', optimistic ? 'items' : undefined).build();
                _context2.next = 6;
                return this.services.network.get(uri);

              case 6:
                response = _context2.sent;
                return _context2.abrupt("return", response.body);

              case 8:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function _get(_x, _x2) {
        return _get2.apply(this, arguments);
      }

      return _get;
    }()
  }, {
    key: "_createDocument",
    value: function _createDocument(id, data, ttl) {
      var requestBody = {
        unique_name: id,
        data: data || {}
      };

      if (ttl !== undefined) {
        requestBody.ttl = ttl;
      }

      return this.services.network.post(this.services.config.documentsUri, requestBody).then(function (response) {
        response.body.data = requestBody.data;
        return response.body;
      });
    }
  }, {
    key: "_getDocument",
    value: function () {
      var _getDocument2 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee3(id) {
        return _regeneratorRuntime__default['default'].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                return _context3.abrupt("return", this.readRootFromSessionCache(SyncDocument.type, id) || this._get(this.services.config.documentsUri, id));

              case 1:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function _getDocument(_x3) {
        return _getDocument2.apply(this, arguments);
      }

      return _getDocument;
    }()
  }, {
    key: "_createList",
    value: function _createList(id, purpose, context, ttl) {
      var requestBody = {
        unique_name: id,
        purpose: purpose,
        context: context
      };

      if (ttl !== undefined) {
        requestBody.ttl = ttl;
      }

      return this.services.network.post(this.services.config.listsUri, requestBody).then(function (response) {
        return response.body;
      });
    }
  }, {
    key: "_getList",
    value: function () {
      var _getList2 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee4(id) {
        return _regeneratorRuntime__default['default'].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                return _context4.abrupt("return", this.readRootFromSessionCache(SyncList.type, id) || this._get(this.services.config.listsUri, id));

              case 1:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function _getList(_x4) {
        return _getList2.apply(this, arguments);
      }

      return _getList;
    }()
  }, {
    key: "_createMap",
    value: function _createMap(id, ttl) {
      var requestBody = {
        unique_name: id
      };

      if (ttl !== undefined) {
        requestBody.ttl = ttl;
      }

      return this.services.network.post(this.services.config.mapsUri, requestBody).then(function (response) {
        return response.body;
      });
    }
  }, {
    key: "_getMap",
    value: function () {
      var _getMap2 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee5(id) {
        var optimistic,
            _args5 = arguments;
        return _regeneratorRuntime__default['default'].wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                optimistic = _args5.length > 1 && _args5[1] !== undefined ? _args5[1] : false;
                return _context5.abrupt("return", this.readRootFromSessionCache(SyncMap.type, id) || this._get(this.services.config.mapsUri, id, optimistic));

              case 2:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function _getMap(_x5) {
        return _getMap2.apply(this, arguments);
      }

      return _getMap;
    }()
  }, {
    key: "_getStream",
    value: function () {
      var _getStream2 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee6(id) {
        return _regeneratorRuntime__default['default'].wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                return _context6.abrupt("return", this.readRootFromSessionCache(SyncStream.type, id) || this._get(this.services.config.streamsUri, id, false));

              case 1:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function _getStream(_x6) {
        return _getStream2.apply(this, arguments);
      }

      return _getStream;
    }()
  }, {
    key: "_createStream",
    value: function () {
      var _createStream2 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee7(id, ttl) {
        var requestBody, response;
        return _regeneratorRuntime__default['default'].wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                requestBody = {
                  unique_name: id
                };

                if (ttl !== undefined) {
                  requestBody.ttl = ttl;
                }

                _context7.next = 4;
                return this.services.network.post(this.services.config.streamsUri, requestBody);

              case 4:
                response = _context7.sent;
                return _context7.abrupt("return", response.body);

              case 6:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function _createStream(_x7, _x8) {
        return _createStream2.apply(this, arguments);
      }

      return _createStream;
    }()
  }, {
    key: "_getLiveQuery",
    value: function _getLiveQuery(sid) {
      return this.readRootFromSessionCache(LiveQuery.type, sid);
    }
  }, {
    key: "getCached",
    value: function getCached(id, type) {
      if (id) {
        return this.entities.get(id, type) || null;
      }

      return null;
    }
  }, {
    key: "removeFromCacheAndSession",
    value: function removeFromCacheAndSession(type, sid, uniqueName) {
      this.entities.remove(sid);

      if (this.services.config.sessionStorageEnabled) {
        this.services.storage.remove(type, sid, uniqueName);
      }
    }
    /**
     * Read or create a Sync document.
     * @param arg Could be any of the following:
     * * Unique name or SID identifying the Sync document - opens the document with the given identifier or creates one if it does not exist.
     * * none - creates a new document with a randomly assigned SID and no unique name.
     * * {@link OpenDocumentOptions} object for more granular control.
     * @return A promise which resolves after the document is successfully read (or created).
     * This promise may reject if the document could not be created or if this endpoint lacks the necessary permissions to access it.
     * @example
     * ```typescript
     * syncClient.document('MyDocument')
     *   .then((document) => {
     *     console.log('Successfully opened a document. SID:', document.sid);
     *     document.on('updated', (event) => {
     *       console.log('Received an "updated" event: ', event);
     *     });
     *   })
     *   .catch((error) => {
     *     console.error('Unexpected error', error);
     *   });
     * ```
     */

  }, {
    key: "document",
    value: function () {
      var _document = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee8(arg) {
        var _this2 = this;

        var opts, docDescriptor, docFromInMemoryCache, syncDocumentImpl;
        return _regeneratorRuntime__default['default'].wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return this.ensureReady();

              case 2:
                opts = decompose(arg);

                if (!(opts.mode === 'create_new')) {
                  _context8.next = 9;
                  break;
                }

                _context8.next = 6;
                return this._createDocument(opts.id, opts.data, opts.ttl);

              case 6:
                docDescriptor = _context8.sent;
                _context8.next = 39;
                break;

              case 9:
                docFromInMemoryCache = this.getCached(opts.id, SyncDocument.type);

                if (!docFromInMemoryCache) {
                  _context8.next = 14;
                  break;
                }

                return _context8.abrupt("return", new SyncDocument(docFromInMemoryCache));

              case 14:
                _context8.prev = 14;
                _context8.next = 17;
                return this._getDocument(opts.id);

              case 17:
                docDescriptor = _context8.sent;
                _context8.next = 39;
                break;

              case 20:
                _context8.prev = 20;
                _context8.t0 = _context8["catch"](14);

                if (!(_context8.t0.status !== 404 || opts.mode === 'open_existing')) {
                  _context8.next = 26;
                  break;
                }

                throw _context8.t0;

              case 26:
                _context8.prev = 26;
                _context8.next = 29;
                return this._createDocument(opts.id, opts.data, opts.ttl);

              case 29:
                docDescriptor = _context8.sent;
                _context8.next = 39;
                break;

              case 32:
                _context8.prev = 32;
                _context8.t1 = _context8["catch"](26);

                if (!(_context8.t1.status === 409)) {
                  _context8.next = 38;
                  break;
                }

                return _context8.abrupt("return", this.document(arg));

              case 38:
                throw _context8.t1;

              case 39:
                this.storeRootInSessionCache(SyncDocument.type, opts.id, docDescriptor);
                syncDocumentImpl = new SyncDocumentImpl(this.services, docDescriptor, function (type, sid, uniqueName) {
                  return _this2.removeFromCacheAndSession(type, sid, uniqueName);
                });
                syncDocumentImpl = this.entities.store(syncDocumentImpl);
                return _context8.abrupt("return", new SyncDocument(syncDocumentImpl));

              case 43:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this, [[14, 20], [26, 32]]);
      }));

      function document(_x9) {
        return _document.apply(this, arguments);
      }

      return document;
    }()
    /**
     * Read or create a Sync map.
     * @param arg Could be any of the following:
     * * Unique name or SID identifying the Sync map - opens the map with the given identifier or creates one if it does not exist.
     * * none - creates a new map with a randomly assigned SID and no unique name.
     * * {@link OpenMapOptions} object for more granular control.
     * @return A promise which resolves after the map is successfully read (or created).
     * This promise may reject if the map could not be created or if this endpoint lacks the necessary permissions to access it.
     * @example
     * ```typescript
     * syncClient.map('MyMap')
     *   .then((map) => {
     *     console.log('Successfully opened a map. SID:', map.sid);
     *     map.on('itemUpdated', (event) => {
     *       console.log('Received an "itemUpdated" event:', event);
     *     });
     *   })
     *   .catch((error) => {
     *     console.error('Unexpected error', error);
     *   });
     * ```
     */

  }, {
    key: "map",
    value: function () {
      var _map = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee9(arg) {
        var _this3 = this;

        var opts, mapDescriptor, mapFromInMemoryCache, syncMapImpl;
        return _regeneratorRuntime__default['default'].wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return this.ensureReady();

              case 2:
                opts = decompose(arg);

                if (!(opts.mode === 'create_new')) {
                  _context9.next = 9;
                  break;
                }

                _context9.next = 6;
                return this._createMap(opts.id, opts.ttl);

              case 6:
                mapDescriptor = _context9.sent;
                _context9.next = 39;
                break;

              case 9:
                mapFromInMemoryCache = this.getCached(opts.id, SyncMap.type);

                if (!mapFromInMemoryCache) {
                  _context9.next = 14;
                  break;
                }

                return _context9.abrupt("return", new SyncMap(mapFromInMemoryCache));

              case 14:
                _context9.prev = 14;
                _context9.next = 17;
                return this._getMap(opts.id, opts.includeItems);

              case 17:
                mapDescriptor = _context9.sent;
                _context9.next = 39;
                break;

              case 20:
                _context9.prev = 20;
                _context9.t0 = _context9["catch"](14);

                if (!(_context9.t0.status !== 404 || opts.mode === 'open_existing')) {
                  _context9.next = 26;
                  break;
                }

                throw _context9.t0;

              case 26:
                _context9.prev = 26;
                _context9.next = 29;
                return this._createMap(opts.id, opts.ttl);

              case 29:
                mapDescriptor = _context9.sent;
                _context9.next = 39;
                break;

              case 32:
                _context9.prev = 32;
                _context9.t1 = _context9["catch"](26);

                if (!(_context9.t1.status === 409)) {
                  _context9.next = 38;
                  break;
                }

                return _context9.abrupt("return", this.map(arg));

              case 38:
                throw _context9.t1;

              case 39:
                this.storeRootInSessionCache(SyncMap.type, opts.id, mapDescriptor);
                syncMapImpl = new SyncMapImpl(this.services, mapDescriptor, function (type, sid, uniqueName) {
                  return _this3.removeFromCacheAndSession(type, sid, uniqueName);
                });
                syncMapImpl = this.entities.store(syncMapImpl);
                return _context9.abrupt("return", new SyncMap(syncMapImpl));

              case 43:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this, [[14, 20], [26, 32]]);
      }));

      function map(_x10) {
        return _map.apply(this, arguments);
      }

      return map;
    }()
    /**
     * Read or create a Sync list.
     * @param arg Could be any of the following:
     * * Unique name or SID identifying a Sync list - opens the list with the given identifier or creates one if it does not exist.
     * * none - creates a new list with a randomly assigned SID and no unique name.
     * * {@link OpenListOptions} object for more granular control.
     * @return A promise which resolves after the list is successfully read (or created).
     * This promise may reject if the list could not be created or if this endpoint lacks the necessary permissions to access it.
     * @example
     * ```typescript
     * syncClient.list('MyList')
     *   .then((list) => {
     *     console.log('Successfully opened a List. SID:', list.sid);
     *     list.on('itemAdded', (event) => {
     *       console.log('Received an "itemAdded" event:', event);
     *     });
     *   })
     *   .catch((error) => {
     *     console.error('Unexpected error', error);
     *   });
     * ```
     */

  }, {
    key: "list",
    value: function () {
      var _list = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee10(arg) {
        var _this4 = this;

        var opts, listDescriptor, listFromInMemoryCache, syncListImpl;
        return _regeneratorRuntime__default['default'].wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                _context10.next = 2;
                return this.ensureReady();

              case 2:
                opts = decompose(arg);

                if (!(opts.mode === 'create_new')) {
                  _context10.next = 9;
                  break;
                }

                _context10.next = 6;
                return this._createList(opts.id, opts.purpose, opts.context, opts.ttl);

              case 6:
                listDescriptor = _context10.sent;
                _context10.next = 39;
                break;

              case 9:
                listFromInMemoryCache = this.getCached(opts.id, SyncList.type);

                if (!listFromInMemoryCache) {
                  _context10.next = 14;
                  break;
                }

                return _context10.abrupt("return", new SyncList(listFromInMemoryCache));

              case 14:
                _context10.prev = 14;
                _context10.next = 17;
                return this._getList(opts.id);

              case 17:
                listDescriptor = _context10.sent;
                _context10.next = 39;
                break;

              case 20:
                _context10.prev = 20;
                _context10.t0 = _context10["catch"](14);

                if (!(_context10.t0.status !== 404 || opts.mode === 'open_existing')) {
                  _context10.next = 26;
                  break;
                }

                throw _context10.t0;

              case 26:
                _context10.prev = 26;
                _context10.next = 29;
                return this._createList(opts.id, opts.purpose, opts.context, opts.ttl);

              case 29:
                listDescriptor = _context10.sent;
                _context10.next = 39;
                break;

              case 32:
                _context10.prev = 32;
                _context10.t1 = _context10["catch"](26);

                if (!(_context10.t1.status === 409)) {
                  _context10.next = 38;
                  break;
                }

                return _context10.abrupt("return", this.list(arg));

              case 38:
                throw _context10.t1;

              case 39:
                this.storeRootInSessionCache(SyncList.type, opts.id, listDescriptor);
                syncListImpl = new SyncListImpl(this.services, listDescriptor, function (type, sid, uniqueName) {
                  return _this4.removeFromCacheAndSession(type, sid, uniqueName);
                });
                syncListImpl = this.entities.store(syncListImpl);
                return _context10.abrupt("return", new SyncList(syncListImpl));

              case 43:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this, [[14, 20], [26, 32]]);
      }));

      function list(_x11) {
        return _list.apply(this, arguments);
      }

      return list;
    }()
    /**
     * Read or create a Sync message stream.
     * @param arg Could be any of the following:
     * * Unique name or SID identifying a stream - opens the stream with the given identifier or creates one if it does not exist.
     * * none - creates a new stream with a randomly assigned SID and no unique name.
     * * {@link OpenStreamOptions} object for more granular control.
     * @return A promise which resolves after the stream is successfully read (or created).
     * The flow of messages will begin imminently (but not necessarily immediately) upon resolution.
     * This promise may reject if the stream could not be created or if this endpoint lacks the necessary permissions to access it.
     * @example
     * ```typescript
     * syncClient.stream('MyStream')
     *   .then((stream) => {
     *     console.log('Successfully opened a message stream. SID:', stream.sid);
     *     stream.on('messagePublished', (event) => {
     *       console.log('Received a "messagePublished" event:', event);
     *     });
     *   })
     *   .catch((error) => {
     *     console.error('Unexpected error', error);
     *   });
     * ```
     */

  }, {
    key: "stream",
    value: function () {
      var _stream = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee11(arg) {
        var _this5 = this;

        var opts, streamDescriptor, streamFromInMemoryCache, streamRemovalHandler, syncStreamImpl;
        return _regeneratorRuntime__default['default'].wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                _context11.next = 2;
                return this.ensureReady();

              case 2:
                opts = decompose(arg);

                if (!(opts.mode === 'create_new')) {
                  _context11.next = 9;
                  break;
                }

                _context11.next = 6;
                return this._createStream(opts.id, opts.ttl);

              case 6:
                streamDescriptor = _context11.sent;
                _context11.next = 39;
                break;

              case 9:
                streamFromInMemoryCache = this.getCached(opts.id, SyncStream.type);

                if (!streamFromInMemoryCache) {
                  _context11.next = 14;
                  break;
                }

                return _context11.abrupt("return", new SyncStream(streamFromInMemoryCache));

              case 14:
                _context11.prev = 14;
                _context11.next = 17;
                return this._getStream(opts.id);

              case 17:
                streamDescriptor = _context11.sent;
                _context11.next = 39;
                break;

              case 20:
                _context11.prev = 20;
                _context11.t0 = _context11["catch"](14);

                if (!(_context11.t0.status !== 404 || opts.mode === 'open_existing')) {
                  _context11.next = 26;
                  break;
                }

                throw _context11.t0;

              case 26:
                _context11.prev = 26;
                _context11.next = 29;
                return this._createStream(opts.id, opts.ttl);

              case 29:
                streamDescriptor = _context11.sent;
                _context11.next = 39;
                break;

              case 32:
                _context11.prev = 32;
                _context11.t1 = _context11["catch"](26);

                if (!(_context11.t1.status === 409)) {
                  _context11.next = 38;
                  break;
                }

                return _context11.abrupt("return", this.stream(arg));

              case 38:
                throw _context11.t1;

              case 39:
                this.storeRootInSessionCache(SyncStream.type, opts.id, streamDescriptor);

                streamRemovalHandler = function streamRemovalHandler(type, sid, uniqueName) {
                  return _this5.removeFromCacheAndSession(type, sid, uniqueName);
                };

                syncStreamImpl = new SyncStreamImpl(this.services, streamDescriptor, streamRemovalHandler);
                syncStreamImpl = this.entities.store(syncStreamImpl);
                return _context11.abrupt("return", new SyncStream(syncStreamImpl));

              case 44:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this, [[14, 20], [26, 32]]);
      }));

      function stream(_x12) {
        return _stream.apply(this, arguments);
      }

      return stream;
    }()
    /**
     * Gracefully shuts the Sync client down.
     */

  }, {
    key: "shutdown",
    value: function () {
      var _shutdown = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee12() {
        return _regeneratorRuntime__default['default'].wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                _context12.next = 2;
                return this.services.subscriptions.shutdown();

              case 2:
                _context12.next = 4;
                return this.services.twilsock.disconnect();

              case 4:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function shutdown() {
        return _shutdown.apply(this, arguments);
      }

      return shutdown;
    }()
    /**
     * Set the authentication token.
     * @param token New token to set.
     */

  }, {
    key: "updateToken",
    value: function () {
      var _updateToken = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee13(token) {
        return _regeneratorRuntime__default['default'].wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                return _context13.abrupt("return", this.services.twilsock.updateToken(token).catch(function (error) {
                  var _error$reply;

                  var status = error === null || error === void 0 ? void 0 : (_error$reply = error.reply) === null || _error$reply === void 0 ? void 0 : _error$reply.status;

                  if ((status === null || status === void 0 ? void 0 : status.code) === 401 && (status === null || status === void 0 ? void 0 : status.status) === 'UNAUTHORIZED') {
                    throw new SyncError('Updated token was rejected by server', 400, 51130);
                  }

                  throw error;
                }));

              case 1:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function updateToken(_x13) {
        return _updateToken.apply(this, arguments);
      }

      return updateToken;
    }()
    /**
     * For Flex customers only. Establishes a long-running query against Flex data wherein the returned
     * result set is updated whenever new (or updated) records match the given expression. Updated results
     * are presented row-by-row according to the lifetime of the returned LiveQuery object.
     *
     * @param indexName Must specify one of the Flex data classes for which Live Queries are available.
     * @param queryExpression A query expression to be executed against the given data index.
     * Please review the [Live Query Language](https://www.twilio.com/docs/sync/live-query)
     * page for Sync client limits and a full list of operators currently supported in query expressions.
     *
     * @return A promise that resolves when the query has been successfully executed.
     * @example
     * ```typescript
     * syncClient.liveQuery('tr-worker', 'data.attributes.worker_name == "Bob"')
     *   .then((args) => {
     *      console.log('Subscribed to live data updates for worker Bob');
     *      const items = args.getItems();
     *      Object.entries(items).forEach(([key, value]) => {
     *        console.log('Search result item key:', key);
     *        console.log('Search result item value:', value);
     *      });
     *   })
     *   .catch((err) => {
     *      console.error('Error when subscribing to live updates for worker Bob', err);
     *   });
     * ```
     */

  }, {
    key: "liveQuery",
    value: function () {
      var _liveQuery = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee14(indexName, queryExpression) {
        var _this6 = this;

        var queryUri, response, liveQueryImpl, descriptor, liveQueryRemovalHandler;
        return _regeneratorRuntime__default['default'].wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                _context14.next = 2;
                return this.ensureReady();

              case 2:
                queryUri = new UriBuilder(this.services.config.insightsUri).pathSegment(indexName).pathSegment('Items').build(); // send query to CDS to get server-generated sid and item list

                _context14.next = 5;
                return queryItems({
                  network: this.services.network,
                  uri: queryUri,
                  queryString: queryExpression,
                  type: LiveQuery.type
                });

              case 5:
                response = _context14.sent;
                liveQueryImpl = this.getCached(response.query_id, LiveQuery.type);

                if (!liveQueryImpl) {
                  descriptor = this._getLiveQuery(response.query_id);

                  if (!descriptor) {
                    descriptor = {
                      indexName: indexName,
                      queryExpression: queryExpression,
                      sid: response.query_id,
                      queryUri: queryUri,
                      last_event_id: response.last_event_id
                    };
                  }

                  liveQueryRemovalHandler = function liveQueryRemovalHandler(type, sid, uniqueName) {
                    return _this6.removeFromCacheAndSession(type, sid, uniqueName);
                  };

                  liveQueryImpl = new LiveQueryImpl(descriptor, this.services, liveQueryRemovalHandler, response.items);
                }

                this.storeRootInSessionCache(LiveQuery.type, response.query_id, liveQueryImpl.liveQueryDescriptor);
                liveQueryImpl = this.entities.store(liveQueryImpl);
                return _context14.abrupt("return", new LiveQuery(liveQueryImpl));

              case 11:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function liveQuery(_x14, _x15) {
        return _liveQuery.apply(this, arguments);
      }

      return liveQuery;
    }()
    /**
     * For Flex customers only. Creates a query object that can be used to issue one-time queries repeatedly
     * against the target index.
     *
     * @param indexName Must specify one of the Flex data classes for which live queries are available.
     * @return A promise which resolves after the instance of InstantQuery is successfully created.
     * @example
     * ```typescript
     * syncClient.instantQuery('tr-worker')
     *   .then((q) => {
     *     q.on('searchResult', (items) => {
     *       Object.entries(items).forEach(([key, value]) => {
     *         console.log('Search result item key:', key);
     *         console.log('Search result item value:', value);
     *       });
     *     });
     *   });
     * ```
     */

  }, {
    key: "instantQuery",
    value: function () {
      var _instantQuery = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee15(indexName) {
        var _this7 = this;

        var liveQueryCreator;
        return _regeneratorRuntime__default['default'].wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                _context15.next = 2;
                return this.ensureReady();

              case 2:
                liveQueryCreator = function liveQueryCreator(indexName, queryExpression) {
                  return _this7.liveQuery(indexName, queryExpression);
                };

                return _context15.abrupt("return", new InstantQuery({
                  indexName: indexName,
                  network: this.services.network,
                  insightsUri: this.services.config.insightsUri,
                  liveQueryCreator: liveQueryCreator
                }));

              case 4:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      function instantQuery(_x16) {
        return _instantQuery.apply(this, arguments);
      }

      return instantQuery;
    }()
  }], [{
    key: "populateInitRegistrations",
    value: function populateInitRegistrations(reg) {
      reg.populateInitRegistrations([SYNC_NOTIFICATION_TYPE, SYNC_DOCUMENT_NOTIFICATION_TYPE, SYNC_LIST_NOTIFICATION_TYPE, SYNC_MAP_NOTIFICATION_TYPE]);
    }
  }, {
    key: "version",
    get: function get() {
      return SDK_VERSION;
    }
  }]);

  return Client;
}(EventEmitter);

_defineProperty__default['default'](Client, "connectionStateChanged", 'connectionStateChanged');

_defineProperty__default['default'](Client, "connectionError", 'connectionError');

_defineProperty__default['default'](Client, "tokenAboutToExpire", 'tokenAboutToExpire');

_defineProperty__default['default'](Client, "tokenExpired", 'tokenExpired');

__decorate([declarativeTypeValidator.validateTypesAsync(['undefined', 'string', declarativeTypeValidator.objectSchema('open document options', {
  id: ['string', 'undefined'],
  mode: [declarativeTypeValidator.literal('open_or_create', 'open_existing', 'create_new'), 'undefined'],
  ttl: [declarativeTypeValidator.nonNegativeInteger, 'undefined'],
  data: [declarativeTypeValidator.pureObject, 'undefined', declarativeTypeValidator.literal(null)]
})]), __metadata("design:type", Function), __metadata("design:paramtypes", [Object]), __metadata("design:returntype", Promise)], Client.prototype, "document", null);

__decorate([declarativeTypeValidator.validateTypesAsync(['undefined', 'string', declarativeTypeValidator.objectSchema('open map options', {
  id: ['string', 'undefined'],
  mode: [declarativeTypeValidator.literal('open_or_create', 'open_existing', 'create_new'), 'undefined'],
  ttl: [declarativeTypeValidator.nonNegativeInteger, 'undefined'],
  data: [declarativeTypeValidator.pureObject, 'undefined', declarativeTypeValidator.literal(null)],
  includeItems: ['boolean', 'undefined']
})]), __metadata("design:type", Function), __metadata("design:paramtypes", [Object]), __metadata("design:returntype", Promise)], Client.prototype, "map", null);

__decorate([declarativeTypeValidator.validateTypesAsync(['undefined', 'string', declarativeTypeValidator.objectSchema('open list options', {
  id: ['string', 'undefined'],
  mode: [declarativeTypeValidator.literal('open_or_create', 'open_existing', 'create_new'), 'undefined'],
  ttl: [declarativeTypeValidator.nonNegativeInteger, 'undefined'],
  data: [declarativeTypeValidator.pureObject, 'undefined', declarativeTypeValidator.literal(null)],
  purpose: ['string', 'undefined'],
  context: [declarativeTypeValidator.pureObject, 'undefined'],
  includeItems: ['boolean', 'undefined']
})]), __metadata("design:type", Function), __metadata("design:paramtypes", [Object]), __metadata("design:returntype", Promise)], Client.prototype, "list", null);

__decorate([declarativeTypeValidator.validateTypesAsync(['undefined', 'string', declarativeTypeValidator.objectSchema('open stream options', {
  id: ['string', 'undefined'],
  mode: [declarativeTypeValidator.literal('open_or_create', 'open_existing', 'create_new'), 'undefined'],
  ttl: [declarativeTypeValidator.nonNegativeInteger, 'undefined'],
  data: [declarativeTypeValidator.pureObject, 'undefined', declarativeTypeValidator.literal(null)]
})]), __metadata("design:type", Function), __metadata("design:paramtypes", [Object]), __metadata("design:returntype", Promise)], Client.prototype, "stream", null);

__decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonEmptyString), __metadata("design:type", Function), __metadata("design:paramtypes", [String]), __metadata("design:returntype", Promise)], Client.prototype, "updateToken", null);

__decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonEmptyString, 'string'), __metadata("design:type", Function), __metadata("design:paramtypes", [String, String]), __metadata("design:returntype", Promise)], Client.prototype, "liveQuery", null);

__decorate([declarativeTypeValidator.validateTypesAsync(declarativeTypeValidator.nonEmptyString), __metadata("design:type", Function), __metadata("design:paramtypes", [String]), __metadata("design:returntype", Promise)], Client.prototype, "instantQuery", null);

exports.Client = Client;
exports.InsightsItem = InsightsItem;
exports.InstantQuery = InstantQuery;
exports.LiveQuery = LiveQuery;
exports.Paginator = Paginator;
exports.SyncClient = Client;
exports.SyncDocument = SyncDocument;
exports.SyncList = SyncList;
exports.SyncListItem = SyncListItem;
exports.SyncMap = SyncMap;
exports.SyncMapItem = SyncMapItem;
exports.SyncStream = SyncStream;
//# sourceMappingURL=browser.js.map
