/// <reference types="wavesurfer.js" />
/// <reference types="react" />
import * as React from "react";
import { EventEmitter } from "eventemitter3";
declare class TimelinePlugin {
    static create(params: TimelinePluginParams): any;
    constructor(params: TimelinePluginParams, ws: object);
    _onScroll: () => void;
    _onRedraw: () => void;
    _onReady: () => void;
    drawer: any;
    pixelRatio: any;
    maxCanvasWidth: any;
    maxCanvasElementWidth: any;
    _onWrapperClick: (e: object) => void;
    container: any;
    wavesurfer: object;
    util: any;
    params: {
        height: number;
        notchPercentHeight: number;
        labelPadding: number;
        unlabeledNotchColor: string;
        primaryColor: string;
        secondaryColor: string;
        primaryFontColor: string;
        secondaryFontColor: string;
        fontFamily: string;
        fontSize: number;
        duration: null;
        zoomDebounce: boolean;
        formatTimeCallback: (seconds: number, pxPerSec: number) => number;
        timeInterval: (pxPerSec: number) => number;
        primaryLabelInterval: (pxPerSec: number) => number;
        secondaryLabelInterval: (pxPerSec: number) => number;
        offset: number;
    } & Object;
    canvases: any[];
    wrapper: any;
    _onZoom: any;
    init(): void;
    destroy(): void;
    createWrapper(): void;
    render(): void;
    addCanvas(): void;
    removeCanvas(): void;
    updateCanvases(): void;
    updateCanvasesPositioning(): void;
    renderCanvases(): void;
    setFillStyles(fillStyle: any | CanvasGradient | CanvasPattern): void;
    setFonts(font: any): void;
    fillRect(x: number, y: number, width: number, height: number): void;
    fillText(text: string, x: number, y: number): void;
    defaultFormatTimeCallback(seconds: number, pxPerSec: number): number;
    defaultTimeInterval(pxPerSec: number): number;
    defaultPrimaryLabelInterval(pxPerSec: number): number;
    defaultSecondaryLabelInterval(pxPerSec: number): number;
}
type TimelinePluginParams = Object;
declare module TimelinePluginWrapper {
    export { TimelinePlugin };
}
declare function defaultTimeFormatter(seconds: number): string;
interface Segment {
    id?: string;
    offset: number;
    duration: number;
}
interface Channel {
    name?: string;
    peaks?: number[];
    color?: string;
    progressColor?: string;
}
type PlaybackRate = number | "very_fast" | "fast" | "normal" | "slow" | "very_slow";
type PlayerOptions = Pick<WaveSurfer.WaveSurferParams, "audioRate" | "backgroundColor" | "barGap" | "barHeight" | "barWidth" | "cursorColor" | "cursorWidth" | "height" | "hideScrollbar" | "progressColor" | "waveColor"> & {
    progressBackgroundColor?: string | null;
    timeline?: TimelineOptions;
    regionColor?: string;
};
type PlayerParams = WaveSurfer.WaveSurferParams & PlayerOptions;
type TimelineOptions = Partial<{
    notchPercentHeight: number;
    unlabeledNotchColor: string;
    primaryColor: string;
    secondaryColor: string;
    primaryFontColor: string;
    secondaryFontColor: string;
    labelPadding: number;
    height: number;
    fontFamily: string;
    fontSize: number;
    formatTimeCallback: (seconds: number, pxPerSec: number) => number | string;
}>;
type PlayerEvents = {
    error: [Error];
    finish: [];
    "hot-load": [];
    play: [];
    pause: [];
    process: [number];
    ready: [];
    redraw: [];
    seek: [number];
};
declare class PlayerCore extends EventEmitter<PlayerEvents> {
    container: HTMLDivElement;
    isHotLoading: boolean;
    mediaElement: HTMLMediaElement | null;
    regionsContainer: HTMLDivElement;
    segmentHighlighterContainer: HTMLDivElement;
    segmentHighlighterLeft: HTMLDivElement;
    segmentHighlighterCenter: HTMLDivElement;
    segmentHighlighterRight: HTMLDivElement;
    timelineContainer: HTMLDivElement;
    waveformContainer: HTMLDivElement;
    waveform?: HTMLElement | null;
    ws?: WaveSurfer;
    wsParams: PlayerParams;
    private currentSegmentDuration?;
    private currentSegmentOffset?;
    constructor(container: HTMLDivElement, opt?: PlayerOptions);
    private initWS;
    private wsHandleAudioProcess;
    private wsHandleError;
    private wsHandleFinish;
    private wsHandlePlay;
    private wsHandlePause;
    private wsHandleReady;
    private wsHandleRedraw;
    private wsHandleSeek;
    renderSegmentHighlight: () => void;
    private timelineFormatter;
    destroy: () => void;
    load: (url: string, channels?: Channel[]) => void;
    hotLoad: (url: string) => Promise<unknown>;
    play: (start?: number | undefined, end?: number | undefined) => Promise<void> | undefined;
    pause: () => Promise<void>;
    getCurrentTime: () => number;
    isPlaying: () => boolean;
    isReady: () => boolean;
    seekToSecond: (seconds: number, offsetFromSegment?: boolean) => void;
    setCurrentSegment: (duration?: number | undefined, offset?: number | undefined) => void;
    setPlaybackRate: (rate?: PlaybackRate) => void;
}
interface PlayerProps {
    channels?: Channel[];
    children?: React.ReactNode;
    currentSegment?: string;
    onReady?: (player: Player) => void;
    onError?: (error: Error) => void;
    options?: PlayerOptions;
    segments?: Segment[];
    style?: React.CSSProperties;
    playbackRate?: PlaybackRate;
    recordingUrl: string;
}
interface PlayerState {
    isReady: boolean;
}
declare class Player extends React.PureComponent<PlayerProps, PlayerState> {
    state: {
        isReady: boolean;
    };
    container: React.RefObject<HTMLDivElement>;
    mediaElement: HTMLMediaElement | null;
    core?: PlayerCore;
    on: PlayerCore["on"];
    once: PlayerCore["once"];
    off: PlayerCore["off"];
    getCurrentTime: () => number | undefined;
    isPlaying: () => boolean;
    isReady: () => boolean;
    play: (start?: number | undefined, end?: number | undefined) => Promise<void> | undefined;
    pause: () => Promise<void>;
    seekToSecond: (seconds: number, offsetFromSegment?: boolean) => void;
    componentDidMount(): void;
    componentWillUnmount(): void;
    componentDidUpdate(prevProps: PlayerProps): void;
    private load;
    private getCurrentSegment;
    private onReady;
    private onError;
    private onRedraw;
    private setPlaybackRate;
    render(): JSX.Element;
}
interface MarkProps {
    children?: React.ReactNode;
    duration: number;
    offset: number;
    color: string;
    offsetFromSegment: boolean;
}
declare class Mark extends React.PureComponent<MarkProps & React.HTMLAttributes<HTMLDivElement>> {
    static defaultProps: {
        duration: number;
        color: string;
        offsetFromSegment: boolean;
    };
    render(): JSX.Element;
    private positionElementStyles;
}
export { Player, Mark, MarkProps, defaultTimeFormatter, Channel, Segment };
//# sourceMappingURL=index.d.ts.map