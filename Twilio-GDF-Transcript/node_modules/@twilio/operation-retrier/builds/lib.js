/*
@license
Copyright (c) 2016, Twilio, Inc.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

*/
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

require('core-js/modules/es.reflect.construct.js');
var _classCallCheck = require('@babel/runtime/helpers/classCallCheck');
var _createClass = require('@babel/runtime/helpers/createClass');
var _assertThisInitialized = require('@babel/runtime/helpers/assertThisInitialized');
var _inherits = require('@babel/runtime/helpers/inherits');
var _possibleConstructorReturn = require('@babel/runtime/helpers/possibleConstructorReturn');
var _getPrototypeOf = require('@babel/runtime/helpers/getPrototypeOf');
var _defineProperty = require('@babel/runtime/helpers/defineProperty');
require('core-js/modules/es.object.to-string.js');
require('core-js/modules/es.promise.js');
var events = require('events');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var _classCallCheck__default = /*#__PURE__*/_interopDefaultLegacy(_classCallCheck);
var _createClass__default = /*#__PURE__*/_interopDefaultLegacy(_createClass);
var _assertThisInitialized__default = /*#__PURE__*/_interopDefaultLegacy(_assertThisInitialized);
var _inherits__default = /*#__PURE__*/_interopDefaultLegacy(_inherits);
var _possibleConstructorReturn__default = /*#__PURE__*/_interopDefaultLegacy(_possibleConstructorReturn);
var _getPrototypeOf__default = /*#__PURE__*/_interopDefaultLegacy(_getPrototypeOf);
var _defineProperty__default = /*#__PURE__*/_interopDefaultLegacy(_defineProperty);

function _createSuper$1(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

function _isNativeReflectConstruct$1() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * Provides retrier service
 */

var Retrier = /*#__PURE__*/function (_EventEmitter) {
  _inherits__default['default'](Retrier, _EventEmitter);

  var _super = _createSuper$1(Retrier);

  // fibonacci strategy

  /**
   * Creates a new Retrier instance
   */
  function Retrier(options) {
    var _this;

    _classCallCheck__default['default'](this, Retrier);

    _this = _super.call(this);

    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), "timeout", null);

    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), "startTimestamp", -1);

    _this.minDelay = options.min;
    _this.maxDelay = options.max;
    _this.initialDelay = options.initial || 0;
    _this.maxAttemptsCount = options.maxAttemptsCount || 0;
    _this.maxAttemptsTime = options.maxAttemptsTime || 0;
    _this.randomness = options.randomness || 0;
    _this.inProgress = false;
    _this.attemptNum = 0;
    _this.prevDelay = 0;
    _this.currDelay = 0;
    return _this;
  }

  _createClass__default['default'](Retrier, [{
    key: "attempt",
    value: function attempt() {
      if (this.timeout) {
        clearTimeout(this.timeout);
        this.timeout = null;
      }

      this.attemptNum++;
      this.emit("attempt", this);
    }
  }, {
    key: "nextDelay",
    value: function nextDelay(delayOverride) {
      if (typeof delayOverride === "number") {
        this.prevDelay = 0;
        this.currDelay = delayOverride;
        return delayOverride;
      }

      if (this.attemptNum == 0) {
        return this.initialDelay;
      }

      if (this.attemptNum == 1) {
        this.currDelay = this.minDelay;
        return this.currDelay;
      }

      this.prevDelay = this.currDelay;
      var delay = this.currDelay + this.prevDelay;

      if (this.maxDelay && delay > this.maxDelay) {
        this.currDelay = this.maxDelay;
        delay = this.maxDelay;
      }

      this.currDelay = delay;
      return delay;
    }
  }, {
    key: "randomize",
    value: function randomize(delay) {
      var area = delay * this.randomness;
      var corr = Math.round(Math.random() * area * 2 - area);
      return Math.max(0, delay + corr);
    }
  }, {
    key: "scheduleAttempt",
    value: function scheduleAttempt(delayOverride) {
      var _this2 = this;

      if (this.maxAttemptsCount && this.attemptNum >= this.maxAttemptsCount) {
        this.cleanup();
        this.emit("failed", new Error("Maximum attempt count limit reached"));
        return;
      }

      var delay = this.nextDelay(delayOverride);
      delay = this.randomize(delay);

      if (this.maxAttemptsTime && this.startTimestamp + this.maxAttemptsTime < Date.now() + delay) {
        this.cleanup();
        this.emit("failed", new Error("Maximum attempt time limit reached"));
        return;
      }

      this.timeout = setTimeout(function () {
        return _this2.attempt();
      }, delay);
    }
  }, {
    key: "cleanup",
    value: function cleanup() {
      if (this.timeout) {
        clearTimeout(this.timeout);
        this.timeout = null;
      }

      this.inProgress = false;
      this.attemptNum = 0;
      this.prevDelay = 0;
      this.currDelay = 0;
    }
  }, {
    key: "start",
    value: function start() {
      if (this.inProgress) {
        throw new Error("Retrier is already in progress");
      }

      this.inProgress = true;
      this.startTimestamp = Date.now();
      this.scheduleAttempt(this.initialDelay);
    }
  }, {
    key: "cancel",
    value: function cancel() {
      if (this.timeout) {
        clearTimeout(this.timeout);
        this.timeout = null;
        this.inProgress = false;
        this.emit("cancelled");
      }
    } // @todo Must be a T here, so the entire Retrier must be typed on this value type.
    // eslint-disable-next-line

  }, {
    key: "succeeded",
    value: function succeeded(arg) {
      this.emit("succeeded", arg);
    }
  }, {
    key: "failed",
    value: function failed(err, nextAttemptDelayOverride) {
      if (this.timeout) {
        throw new Error("Retrier attempt is already in progress");
      }

      this.scheduleAttempt(nextAttemptDelayOverride);
    }
  }]);

  return Retrier;
}(events.EventEmitter);
/**
 * Run retrier as an async function with possibility to await for it.
 * Example:
 * ```
 * const result = AsyncRetrier.run(async () => somePromise);
 * ```
 */


var AsyncRetrier = /*#__PURE__*/function (_EventEmitter2) {
  _inherits__default['default'](AsyncRetrier, _EventEmitter2);

  var _super2 = _createSuper$1(AsyncRetrier);

  // This any must be T typed directly on the AsyncRetrier
  // eslint-disable-next-line
  function AsyncRetrier(options) {
    var _this3;

    _classCallCheck__default['default'](this, AsyncRetrier);

    _this3 = _super2.call(this);

    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this3), "resolve", function () {
      return void 0;
    });

    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this3), "reject", function () {
      return void 0;
    });

    _this3.retrier = new Retrier(options);
    return _this3;
  }

  _createClass__default['default'](AsyncRetrier, [{
    key: "run",
    value: function run(handler) {
      var _this4 = this;

      this.retrier.on("attempt", function () {
        handler().then(function (v) {
          return _this4.retrier.succeeded(v);
        }).catch(function (e) {
          return _this4.retrier.failed(e);
        });
      });
      this.retrier.on("succeeded", function (arg) {
        return _this4.resolve(arg);
      });
      this.retrier.on("cancelled", function () {
        return _this4.reject(new Error("Cancelled"));
      });
      this.retrier.on("failed", function (err) {
        return _this4.reject(err);
      });
      return new Promise(function (resolve, reject) {
        _this4.resolve = resolve;
        _this4.reject = reject;

        _this4.retrier.start();
      });
    }
  }, {
    key: "cancel",
    value: function cancel() {
      this.retrier.cancel();
    }
  }]);

  return AsyncRetrier;
}(events.EventEmitter);

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function isDef(value) {
  return value !== undefined && value !== null;
}

var Backoff = /*#__PURE__*/function (_EventEmitter) {
  _inherits__default['default'](Backoff, _EventEmitter);

  var _super = _createSuper(Backoff);

  function Backoff(options) {
    var _this;

    _classCallCheck__default['default'](this, Backoff);

    _this = _super.call(this);

    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), "backoffDelay", 0);

    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), "nextBackoffDelay", 0);

    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), "backoffNumber", 0);

    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), "timeoutID", null);

    _defineProperty__default['default'](_assertThisInitialized__default['default'](_this), "maxNumberOfRetry", -1);

    options = options || {};
    var _options = options,
        initialDelay = _options.initialDelay,
        maxDelay = _options.maxDelay,
        randomisationFactor = _options.randomisationFactor,
        factor = _options.factor;

    if (isDef(initialDelay) && initialDelay < 1) {
      throw new Error("The initial timeout must be equal to or greater than 1.");
    }

    if (isDef(maxDelay) && maxDelay <= 1) {
      throw new Error("The maximal timeout must be greater than 1.");
    }

    if (isDef(randomisationFactor) && (randomisationFactor < 0 || randomisationFactor > 1)) {
      throw new Error("The randomisation factor must be between 0 and 1.");
    }

    if (isDef(factor) && factor <= 1) {
      throw new Error("Exponential factor should be greater than 1.");
    }

    _this.initialDelay = initialDelay || 100;
    _this.maxDelay = maxDelay || 10000;

    if (_this.maxDelay <= _this.initialDelay) {
      throw new Error("The maximal backoff delay must be greater than the initial backoff delay.");
    }

    _this.randomisationFactor = randomisationFactor || 0;
    _this.factor = factor || 2;

    _this.reset();

    return _this;
  }

  _createClass__default['default'](Backoff, [{
    key: "backoff",
    value: function backoff(err) {
      if (this.timeoutID == null) {
        if (this.backoffNumber === this.maxNumberOfRetry) {
          this.emit("fail", err);
          this.reset();
        } else {
          this.backoffDelay = this.next();
          this.timeoutID = setTimeout(this.onBackoff.bind(this), this.backoffDelay);
          this.emit("backoff", this.backoffNumber, this.backoffDelay, err);
        }
      }
    }
  }, {
    key: "reset",
    value: function reset() {
      this.backoffDelay = 0;
      this.nextBackoffDelay = this.initialDelay;
      this.backoffNumber = 0;

      if (this.timeoutID) {
        clearTimeout(this.timeoutID);
      }

      this.timeoutID = null;
    }
  }, {
    key: "failAfter",
    value: function failAfter(maxNumberOfRetry) {
      if (maxNumberOfRetry <= 0) {
        throw new Error("Expected a maximum number of retry greater than 0 but got ".concat(maxNumberOfRetry));
      }

      this.maxNumberOfRetry = maxNumberOfRetry;
    }
  }, {
    key: "next",
    value: function next() {
      this.backoffDelay = Math.min(this.nextBackoffDelay, this.maxDelay);
      this.nextBackoffDelay = this.backoffDelay * this.factor;
      var randomisationMultiple = 1 + Math.random() * this.randomisationFactor;
      return Math.min(this.maxDelay, Math.round(this.backoffDelay * randomisationMultiple));
    }
  }, {
    key: "onBackoff",
    value: function onBackoff() {
      this.timeoutID = null;
      this.emit("ready", this.backoffNumber, this.backoffDelay);
      this.backoffNumber++;
    }
  }], [{
    key: "exponential",
    value: function exponential(options) {
      return new Backoff(options);
    }
  }]);

  return Backoff;
}(events.EventEmitter);

exports.AsyncRetrier = AsyncRetrier;
exports.Backoff = Backoff;
exports.Retrier = Retrier;
//# sourceMappingURL=lib.js.map
